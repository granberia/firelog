---
title: VS Code에서 마크다운 내부 체크박스를 클릭으로 토글되게 하자
date: 2025-10-28 12:52:29 +0900
categories: [개발]
tags: [개발, 블로그]
---


나는 블로그에 매주 갱신하는 계획표를 VS Code에서 이런 형태로 작성하고 수정한다.

```md
### 2025.10.27 ~ 2025.11.02
- [x] 중간에 하다 만 블랙 옵스 3 클리어
- [ ] 지난 한 달간 클리어한 게임들의 후기 작성
  - [ ] 마법소녀의 마녀재판
  - [ ] 건파이어 리본
  - [ ] 콜 오브 듀티: 블랙 옵스 3
- [ ] 패스파인더: 이스투아 세션 43화 AI 지식 베이스 최신화
- [ ] 개발 환경에 무료 Cursor AI 적용하기
- [ ] RisuAI 에셋 모듈 뜯어보고 구조 분석하기
- [ ] RisuAI가 프롬프트를 조합하는 방법 리서치
- [ ] 엑스페리온 세계관 문서 링크 정리 및 지식 베이스화 시도

### 주간 체크리스트

| 할일        | 월요일 | 화요일 | 수요일 | 목요일 | 금요일 | 토요일 | 일요일 |
| :---------- | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 영양제 먹기 |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |
| 스트레칭    |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |
| 달리기      |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |  [ ]   |
```

여기서 완료된 목표 부분의 [ ] 를 [x] 로 변경하는 식으로 체크박스에 체크를 해왔는데, 이제까진 별로 귀찮지 않았다.

그런데 오늘 체크리스트 표를 넣으면서 매일 정확한 위치에 마우스 커서를 가져다 대고, 클릭하고, x를 써넣고... 하는 건 귀찮아보인다.

github 코멘트처럼 체크박스를 클릭하기만 해도 자동으로 토글시켜주는 UI가 있으면 좋겠다는 생각이 들었다.

가장 먼저 VS Code 플러그인을 리서치해봤다. MarkClick.md 라는 플러그인이 마크다운 기본 문법에서 지원하는 체크박스들에 대해 잘 동작했다.

문제는 지난 포스트에서처럼 내가 임의로 [ ] 를 체크박스로 인식하고 동작하게 만드는 경우에 대해 당연하게도 지원해주지 않는다.

내가 직접 플러그인의 코드를 수정해서 동작하게 만들어야겠지. 

VS Code 플러그인의 설치 경로는 `C:\Users\이름\.vscode\extensions` 고 수정하려는 플러그인 폴더명은 kyuukab.markclick-md-0.0.3 이다.

경로 내의 out/markdownParser.js 에 파일 내부 체크박스들을 인식하는 로직이 있는 것 같다.

`static CHECKBOX_PATTERN = /^(\s*)-\s*\[([ xX])\](.*)$/;` 라는 정규식을 사용해서 체크박스를 추출하고,

`findCheckboxes` 라는 함수 내에서 각 체크박스들의 정보를 반환하는 것 같으니 이 두 곳을 고치면 되지 않을까?

요구 사항을 LLM에게 전달하면 얼마나 깔끔하게 수정해주는지 보자.

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

네, 물론입니다. 기존 코드는 마크다운의 리스트 항목(`- [ ]`)에만 존재하는 체크박스를 찾도록 설계되어 있습니다. 이를 문서 내 모든 위치의 체크박스(`[ ]`, `[x]`, `[X]`)를 찾도록 수정하려면 정규식뿐만 아니라, 해당 정규식의 결과를 처리하는 로직도 함께 변경해야 합니다.

가장 큰 변화는 한 줄에서 **여러 개의 체크박스**를 발견할 수 있다는 점을 고려하는 것입니다.

아래에 수정한 전체 코드를 제공하고, 주요 변경 사항을 설명해 드리겠습니다.

### 주요 변경 사항

1.  **`CHECKBOX_PATTERN` 변경**:
    *   기존: `/^(\s*)-\s*\[([ xX])\](.*)$/`
    *   변경: `/\[([ xX])\]/g`
    *   `^`, `$`, `-` 등 리스트 형식을 강제하는 모든 요소를 제거했습니다.
    *   `g` (global) 플래그를 추가하여 한 줄에서 여러 개의 일치 항목을 모두 찾을 수 있도록 했습니다.

2.  **`findCheckboxes` 메소드 로직 수정**:
    *   기존에는 `line.match()`를 사용하여 한 줄에 하나의 체크박스만 찾는 구조였습니다.
    *   새로운 로직에서는 `while ((match = CHECKBOX_PATTERN.exec(line)) !== null)` 루프를 사용합니다. 이를 통해 `g` 플래그와 함께 작동하여 한 줄에 있는 모든 체크박스를 순차적으로 찾아 처리할 수 있습니다.
    *   **위치 계산 변경**: `match.index` 속성을 사용하여 현재 줄에서 발견된 체크박스의 정확한 시작 위치를 가져옵니다.
    *   **들여쓰기(Indent) 처리**: 새로운 정규식은 들여쓰기를 캡처하지 않습니다. 따라서 체크박스가 리스트 항목의 일부인지 확인하기 위해, 발견된 체크박스 앞의 문자열(`line.substring(...)`)을 분석하여 들여쓰기 수준을 계산하는 로직을 추가했습니다. 테이블 내의 체크박스처럼 리스트 항목이 아닌 경우 들여쓰기 수준은 0이 됩니다.

3.  **관련 주석 업데이트**:
    *   코드 내의 정규식 설명 주석을 새로운 정규식에 맞게 수정했습니다.

---

### 수정된 전체 코드

```typescript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownParser = void 0;
const checkbox_1 = require("../types/checkbox");
/**
 * マークダウンファイル内のチェックボックスを解析するユーティリティクラス
 */
class MarkdownParser {
    /**
     * チェックボックス検出用の正規表現パターン
     * - \[: 대괄호 '[' 문자
     * - ([ xX]): 공백, 'x', 또는 'X' 문자를 캡처 (캡처 그룹 1)
     * - \]: 대괄호 ']' 문자
     * - g: 전역 플래그, 한 줄에서 모든 일치 항목을 찾음
     */
    static CHECKBOX_PATTERN = /\[([ xX])\]/g;
    /**
     * パフォーマンス制限: 大きなファイルに対する処理制限
     */
    static MAX_LINES_FOR_FULL_PARSING = 50000;
    static MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10MB
    /**
     * 結果キャッシュ（メモリ効率を考慮したLRU風のキャッシュ）
     */
    static parseCache = new Map();
    static MAX_CACHE_SIZE = 50;
    /**
     * デバウンシング用のタイマー管理
     */
    static debounceTimers = new Map();
    /**
     * マークダウンテキスト内のチェックボックスを検出する（最適化版）
     * @param text - 解析対象のマークダウンテキスト
     * @param options - 解析オプション
     * @returns ParseResult - 検出されたチェックボックス情報
     */
    static findCheckboxes(text, options) {
        const { useCache = true, cacheKey, maxLines } = options || {};
        // パフォーマンス制限チェック
        if (text.length > MarkdownParser.MAX_FILE_SIZE_BYTES) {
            return {
                checkboxes: [],
                success: false,
                error: `File too large (${text.length} bytes). Maximum allowed: ${MarkdownParser.MAX_FILE_SIZE_BYTES}`,
                totalLines: 0,
            };
        }
        // キャッシュチェック
        if (useCache && cacheKey && MarkdownParser.parseCache.has(cacheKey)) {
            const cached = MarkdownParser.parseCache.get(cacheKey);
            if (cached) {
                return cached;
            }
        }
        try {
            const checkboxes = [];
            const lines = text.split("\n");
            // 行数制限チェック
            const effectiveMaxLines = maxLines || MarkdownParser.MAX_LINES_FOR_FULL_PARSING;
            if (lines.length > effectiveMaxLines) {
                return {
                    checkboxes: [],
                    success: false,
                    error: `Too many lines (${lines.length}). Maximum allowed: ${effectiveMaxLines}`,
                    totalLines: lines.length,
                };
            }
            const codeBlockRanges = MarkdownParser.findCodeBlockRanges(lines);
            // 각 행을 처리
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                // 최적화: 체크박스가 없을 가능성이 높은 행은 건너뜀
                if (!line.includes("[")) {
                    continue;
                }
                // 코드 블록 내의 행은 건너뜀
                if (MarkdownParser.isInCodeBlock(lineIndex, codeBlockRanges)) {
                    continue;
                }

                let match;
                // g 플래그를 사용하므로 exec()를 루프에서 호출하여 한 줄의 모든 체크박스를 찾음
                while ((match = MarkdownParser.CHECKBOX_PATTERN.exec(line)) !== null) {
                    const checkboxChar = match[1]; // 캡처 그룹 1: ' ', 'x', 'X'
                    const checkboxStart = match.index;
                    const checkboxEnd = checkboxStart + 3; // '[x]'의 길이

                    // 인라인 코드(`code`) 내의 체크박스는 제외
                    if (MarkdownParser.isInInlineCode(line, checkboxStart)) {
                        continue;
                    }

                    // 들여쓰기 수준 계산 (리스트 항목인 경우에만 의미 있음)
                    let indent = "";
                    let indentLevel = 0;
                    // 체크박스 앞부분이 마크다운 리스트 형식인지 확인
                    const linePrefix = line.substring(0, checkboxStart);
                    const listPrefixMatch = linePrefix.match(/^(\s*)-\s*$/);
                    if (listPrefixMatch) {
                        indent = listPrefixMatch[1] || "";
                        indentLevel = MarkdownParser.calculateIndentLevel(indent);
                    }

                    const checkboxMatch = {
                        line: lineIndex,
                        startPos: checkboxStart,
                        endPos: checkboxEnd,
                        state: checkboxChar.trim() !== ""
                            ? checkbox_1.CheckboxState.CHECKED
                            : checkbox_1.CheckboxState.UNCHECKED,
                        fullMatch: line,
                        indentLevel: indentLevel,
                    };
                    checkboxes.push(checkboxMatch);
                }
            }
            const result = {
                checkboxes,
                success: true,
                totalLines: lines.length,
            };
            // キャッシュに保存（LRU風の管理）
            if (useCache && cacheKey) {
                MarkdownParser.setCacheResult(cacheKey, result);
            }
            return result;
        }
        catch (error) {
            const errorResult = {
                checkboxes: [],
                success: false,
                error: error instanceof Error ? error.message : "Unknown parsing error",
                totalLines: 0,
            };
            // エラー結果もキャッシュする（一時的なエラーを防ぐため）
            if (useCache && cacheKey) {
                MarkdownParser.setCacheResult(cacheKey, errorResult);
            }
            return errorResult;
        }
    }
    /**
     * キャッシュに結果を保存（LRU風の管理）
     * @param key - キャッシュキー
     * @param result - 保存する結果
     */
    static setCacheResult(key, result) {
        // キャッシュサイズ制限
        if (MarkdownParser.parseCache.size >= MarkdownParser.MAX_CACHE_SIZE) {
            // 最も古いエントリを削除（Map の最初のキー）
            const firstKey = MarkdownParser.parseCache.keys().next().value;
            if (firstKey) {
                MarkdownParser.parseCache.delete(firstKey);
            }
        }
        MarkdownParser.parseCache.set(key, result);
    }
    /**
     * キャッシュをクリアする
     */
    static clearCache() {
        MarkdownParser.parseCache.clear();
    }
    /**
     * デバウンシング付きのチェックボックス検出
     * @param text - 解析対象のマークダウンテキスト
     * @param key - デバウンシングキー
     * @param delay - デバウンシング遅延（ミリ秒）
     * @returns Promise<ParseResult>
     */
    static findCheckboxesDebounced(text, key, delay = 300) {
        return new Promise((resolve) => {
            // 既存のタイマーをクリア
            const existingTimer = MarkdownParser.debounceTimers.get(key);
            if (existingTimer) {
                clearTimeout(existingTimer);
            }
            // 新しいタイマーを設定
            const timer = setTimeout(() => {
                const result = MarkdownParser.findCheckboxes(text, {
                    cacheKey: key,
                    useCache: true,
                });
                MarkdownParser.debounceTimers.delete(key);
                resolve(result);
            }, delay);
            MarkdownParser.debounceTimers.set(key, timer);
        });
    }
    /**
     * インデントレベルを計算する
     * @param indent - インデント文字列（スペースまたはタブ）
     * @returns インデントレベル（タブは4スペース相当として計算）
     */
    static calculateIndentLevel(indent) {
        let level = 0;
        for (const char of indent) {
            if (char === "\t") {
                level += 4; // タブは4スペース相当
            }
            else if (char === " ") {
                level += 1;
            }
        }
        return Math.floor(level / 2); // 2スペースを1レベルとして計算
    }
    /**
     * 指定した行と位置にチェックボックスが存在するかを確認する
     * @param text - マークダウンテキスト
     * @param line - 行番号（0ベース）
     * @param position - 行内の位置
     * @returns チェックボックスが存在する場合はCheckboxMatch、存在しない場合はnull
     */
    static getCheckboxAt(text, line, position) {
        const parseResult = MarkdownParser.findCheckboxes(text);
        if (!parseResult.success) {
            return null;
        }
        return (parseResult.checkboxes.find((checkbox) => checkbox.line === line &&
            position >= checkbox.startPos &&
            position <= checkbox.endPos) || null);
    }
    /**
     * テキスト内のチェックボックス総数を取得する
     * @param text - マークダウンテキスト
     * @returns チェックボックスの総数
     */
    static getCheckboxCount(text) {
        const parseResult = MarkdownParser.findCheckboxes(text);
        return parseResult.success ? parseResult.checkboxes.length : 0;
    }
    /**
     * チェック済みチェックボックスの数を取得する
     * @param text - マークダウンテキスト
     * @returns チェック済みチェックボックスの数
     */
    static getCheckedCount(text) {
        const parseResult = MarkdownParser.findCheckboxes(text);
        if (!parseResult.success) {
            return 0;
        }
        return parseResult.checkboxes.filter((checkbox) => checkbox.state === checkbox_1.CheckboxState.CHECKED).length;
    }
    /**
     * コードブロックの範囲を検出する
     * @param lines - ファイルの各行の配列
     * @returns コードブロックの開始・終了行の配列
     */
    static findCodeBlockRanges(lines) {
        const ranges = [];
        let inFencedBlock = false;
        let inIndentedBlock = false;
        let fencedBlockStart = -1;
        let indentedBlockStart = -1;
        let previousLineWasEmpty = true;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmedLine = line.trim();
            // フェンス付きコードブロック（```または~~~）の処理
            if (trimmedLine.match(/^```|^~~~/)) {
                if (!inFencedBlock) {
                    inFencedBlock = true;
                    fencedBlockStart = i;
                }
                else {
                    inFencedBlock = false;
                    ranges.push({ start: fencedBlockStart, end: i });
                }
                continue;
            }
            // 既にフェンス付きブロック内の場合はスキップ
            if (inFencedBlock) {
                continue;
            }
            // インデント付きコードブロック（4スペース以上のインデント）の処理
            // タブインデントでチェックボックスがある行は除外
            const hasTabCheckbox = line.match(/^\t.*-\s*\[[ xX]\]/);
            const isIndentedCode = !hasTabCheckbox && (line.match(/^ {4}/) || line.match(/^\t/));
            const isEmpty = trimmedLine === "";
            if (isIndentedCode && (previousLineWasEmpty || inIndentedBlock)) {
                if (!inIndentedBlock) {
                    inIndentedBlock = true;
                    indentedBlockStart = i;
                }
            }
            else if (inIndentedBlock && !isEmpty && !isIndentedCode) {
                inIndentedBlock = false;
                ranges.push({ start: indentedBlockStart, end: i - 1 });
            }
            previousLineWasEmpty = isEmpty;
        }
        // ファイル終端でのコードブロック処理
        if (inFencedBlock) {
            ranges.push({ start: fencedBlockStart, end: lines.length - 1 });
        }
        if (inIndentedBlock) {
            ranges.push({ start: indentedBlockStart, end: lines.length - 1 });
        }
        return ranges;
    }
    /**
     * 指定した行がコードブロック内にあるかを判定する
     * @param lineIndex - 検査対象の行番号
     * @param codeBlockRanges - コードブロックの範囲配列
     * @returns コードブロック内の場合はtrue
     */
    static isInCodeBlock(lineIndex, codeBlockRanges) {
        return codeBlockRanges.some((range) => lineIndex >= range.start && lineIndex <= range.end);
    }
    /**
     * インラインコード（`code`）内のチェックボックスを除外する
     * @param line - 検査対象の行
     * @param position - チェックボックスの位置
     * @returns インラインコード内の場合はtrue
     */
    static isInInlineCode(line, position) {
        let inCode = false;
        let codeStartPos = -1;
        for (let i = 0; i < line.length; i++) {
            if (line[i] === "`") {
                if (!inCode) {
                    inCode = true;
                    codeStartPos = i;
                }
                else {
                    // コードブロック終了
                    if (position > codeStartPos && position < i) {
                        return true;
                    }
                    inCode = false;
                }
            }
        }
        return false;
    }
}
exports.MarkdownParser = MarkdownParser;
//# sourceMappingURL=markdownParser.js.map
```

</details>
<br>

체크박스 쪽 정규식을 `static CHECKBOX_PATTERN = /\[([ xX])\]/g;` 로 바꾼 거랑 아래쪽 함수 로직 정도만 수정한 것 같다.

잘 작동하는 것 같으니 이제 계획표 관리하기가 덜 귀찮아지겠지?
