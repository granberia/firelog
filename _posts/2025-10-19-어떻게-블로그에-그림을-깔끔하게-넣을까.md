---
title: 어떻게 블로그에 그림을 깔끔하게 넣을까
date: 2025-10-19 04:07:03 +0900
categories: [개발]
tags: [개발, 블로그]
---

블로그를 만든 지 3주 정도 지난 것 같다. 이미지를 편리하게 넣는 기능이 없어서 크게 불편한 적은 없지만, 그래도 이미지가 없는 게 허전하다.

포스트를 작성할 때 VS Code를 사용하는데, 에디터에서 드래그 앤 드롭으로 마크다운 파일 내부에 이미지 링크를 넣는 방법을 연구해보자.

LLM들에게 질문하면 적당한 VS Code 플러그인을 추천해주지 않을까? 

아래의 질문을 던져보자.

`github에서 이슈를 작성할 때 그림 파일을 드래그 앤 드롭하면 마크다운 안에 이미지 링크를 자동으로 넣어줘. VS Code에서 마크다운 파일을 편집할 때에도 그렇게 편하게 그림 파일을 삽입할 수 있는 방법이 있을까?`

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

네, 물론입니다! GitHub에서처럼 VS Code에서도 마크다운 파일에 이미지를 아주 편하게 삽입할 수 있는 방법들이 있습니다. 크게 2가지 방법이 있는데, **강력한 확장(Extension)을 사용하는 방법**과 **VS Code 내장 기능을 활용하는 방법**입니다.

### 추천 1: 확장(Extension) 사용하기 (가장 강력하고 편리한 방법)

이 방법이 GitHub의 경험과 가장 유사하며, 훨씬 더 많은 기능을 제공합니다. 가장 유명하고 강력한 확장은 **Paste Image**입니다.

#### **Paste Image 확장**

이 확장을 사용하면 클립보드에 복사된 이미지나 파일 탐색기에서 드래그한 이미지를 바로 마크다운에 삽입하고, 이미지 파일 자체도 프로젝트 폴더 내 지정된 위치로 **자동으로 복사/저장**해 줍니다.

**설치 및 사용법:**

1.  **확장 설치**: VS Code의 확장(Extensions) 탭(Ctrl+Shift+X)에서 `Paste Image`를 검색하여 설치합니다.

2.  **이미지 삽입 방법**:
    *   **클립보드에서 붙여넣기 (가장 편리!)**:
        1.  웹 브라우저, 그림판, 캡처 도구 등에서 이미지를 복사합니다 (Ctrl+C).
        2.  VS Code 마크다운 편집기에서 이미지를 넣고 싶은 위치에 커서를 두고 `Ctrl+Alt+V` (Windows/Linux) 또는 `Cmd+Opt+V` (Mac)를 누릅니다.
    *   **파일 탐색기에서 드래그 앤 드롭**:
        *   이 확장은 주로 클립보드 붙여넣기에 최적화되어 있지만, 드래그 앤 드롭 기능도 다른 확장과 연계하거나 VS Code 내장 기능으로 보완할 수 있습니다. `Paste Image`의 핵심은 **파일 자동 저장 및 경로 생성**입니다.

3.  **핵심 기능 및 설정 (매우 중요!)**:
    `Paste Image`의 진가는 설정을 통해 발휘됩니다. VS Code의 `settings.json` 파일(Ctrl+, 누르고 우상단 파일 아이콘 클릭)을 열어 아래와 같이 설정하면 매우 편리합니다.

    ```json
    {
      // 이미지가 저장될 경로를 지정합니다.
      // ${currentFileDir}는 현재 편집 중인 마크다운 파일이 있는 폴더를 의미합니다.
      // 예: /project/docs/writing.md -> /project/docs/images
      "pasteImage.path": "${currentFileDir}/images",

      // 마크다운에 삽입될 이미지 링크의 기본 경로를 설정합니다.
      // 일반적으로 위 경로와 동일하게 설정하면 상대 경로로 잘 동작합니다.
      "pasteImage.basePath": "${currentFileDir}/images",

      // 저장될 이미지 파일의 이름을 지정합니다.
      // YYYY-MM-DD-HH-mm-ss 형식으로 파일명이 자동 생성되어 중복을 방지합니다.
      "pasteImage.defaultName": "Y-MM-DD-HH-mm-ss",

      // 파일 이름에 접두사나 접미사를 추가할 수도 있습니다.
      "pasteImage.prefix": "",
      "pasteImage.suffix": ""
    }
    ```

**왜 이 방법이 좋은가?**

*   **자동 파일 관리**: 외부 이미지를 프로젝트 폴더 안으로 자동으로 복사해오므로, 나중에 이미지가 깨질 염려가 없습니다.
*   **일관된 경로**: 모든 이미지를 `images` 같은 특정 폴더에 모아서 관리할 수 있습니다.
*   **자동 이름 생성**: 날짜/시간 기반으로 파일명을 만들어주어 파일명이 겹치지 않게 관리하기 편합니다.

---

### 추천 2: VS Code 내장 기능 활용하기 (설치 없이 바로 사용)

최신 버전의 VS Code는 마크다운 이미지 삽입 편의 기능이 내장되어 있습니다. 별도 확장 설치가 부담스럽다면 이 방법을 사용해도 좋습니다.

#### 방법 A: 파일 탐색기에서 드래그 앤 드롭

1.  VS Code의 탐색기(Explorer) 패널에 이미지 파일이 이미 존재해야 합니다.
2.  탐색기 패널에서 이미지 파일(`my-image.png`)을 클릭하여 마크다운 편집창의 원하는 위치로 **드래그 앤 드롭**합니다.
3.  `![my-image](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/my-image.png)` 와 같이 자동으로 상대 경로의 마크다운 링크가 생성됩니다.

> **단점**: 이 방법은 프로젝트 외부에 있는 파일을 드래그할 때 파일을 프로젝트 폴더로 복사해주지는 않습니다. 단순히 파일 경로만 링크합니다.

#### 방법 B: 클립보드에서 이미지 붙여넣기 (내장 기능)

VS Code는 이제 `Paste Image` 확장처럼 클립보드 이미지 붙여넣기를 기본적으로 지원합니다!

1.  이미지를 클립보드에 복사합니다.
2.  마크다운 파일에서 `Ctrl+V` (일반 붙여넣기)를 하면 이미지를 어떻게 처리할지 묻거나, 설정에 따라 바로 파일로 저장하고 링크를 삽입합니다.

**내장 기능 설정하기**:
이 기능도 `settings.json`에서 동작을 제어할 수 있습니다.

```json
{
  // 마크다운 파일에 이미지를 붙여넣을 때 파일 복사 동작을 활성화합니다.
  "markdown.editor.pasteUrlAsFormattedLink.enabled": true,

  // 복사된 이미지 파일이 저장될 위치를 지정합니다.
  "markdown.copyFiles.destination": {
    // 현재 마크다운 파일이 있는 폴더(${documentDir}) 아래의 images 폴더에 저장
    "**/*": "${documentDir}/images/"
  }
}
```

---

### 최종 요약 및 추천

| 기능                    | Paste Image (확장)                  | VS Code 내장 기능                        |
| ----------------------- | ----------------------------------- | ---------------------------------------- |
| **드래그 앤 드롭**      | (내장 기능으로 보완)                | **프로젝트 내 파일**에 한해 매우 잘 동작 |
| **클립보드 붙여넣기**   | **강력함 (단축키: Ctrl+Alt+V)**     | **기본 지원**                            |
| **파일 자동 복사/저장** | **O (핵심 기능)**                   | **O (설정 필요)**                        |
| **파일 이름 자동 생성** | **O (YYYY-MM-DD-HH-mm-ss 등 다양)** | △ (기본적으로 임의의 이름, 설정 복잡)    |
| **경로 설정 유연성**    | **매우 높음**                       | 좋음                                     |
| **설치 필요 여부**      | 필요                                | **불필요**                               |

**결론:**

*   **최고의 편의성과 강력한 파일 관리**를 원한다면 망설이지 말고 **`Paste Image` 확장**을 설치하세요. GitHub와 가장 유사하면서도 그 이상의 경험을 제공합니다.
*   **별도 확장 설치 없이 가볍게 사용**하고 싶다면 **VS Code 내장 기능**을 활용하고, `settings.json`에서 저장 경로 정도만 설정해두면 충분히 편리하게 사용할 수 있습니다.

</details>

### GPT-5의 결과물


<details markdown="1">
<summary>접기/펴기</summary>

좋은 질문이야 👍
맞아, GitHub에서는 이미지를 드래그 앤 드롭하면 자동으로 업로드되고
`![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/https://user-images.githubusercontent.com/...)` 형식으로 바로 마크다운 링크를 넣어주지.

VS Code에서도 **비슷한 방식으로 이미지 삽입을 자동화**할 수 있어.
다만 **이미지를 업로드할 서버**나 **로컬에 저장할 위치**를 직접 설정해야 해.

---

## ✅ 방법 1. **Paste Image** 확장(extension) 사용 (가장 많이 쓰이는 방법)

**확장 이름:** [**Paste Image** by mushan](https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image)

### 🧩 기능 요약

* 클립보드의 이미지를 붙여넣으면 (`Ctrl+Alt+V`)
  → 지정된 폴더에 파일을 자동 저장하고
  → 마크다운에 `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/경로)`를 자동으로 삽입함.
* 드래그 앤 드롭 대신 **복사-붙여넣기 (Ctrl+V)** 형태지만, 매우 유사한 UX야.

### ⚙️ 설정 예시 (`settings.json`)

```json
{
  "pasteImage.path": "${currentFileDir}/images",
  "pasteImage.prefix": "images/",
  "pasteImage.basePath": "${currentFileDir}",
  "pasteImage.insertPattern": "![${imageFileNameWithoutExt}](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/${imageFilePath})"
}
```

이렇게 설정하면
예를 들어 `post.md`에 이미지를 붙여넣을 때
자동으로 `./images/image-20251017.png`가 생성되고
본문에는

```markdown
![image-20251017](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/images/image-20251017.png)
```

이 들어가.

---

## ✅ 방법 2. **Markdown Image** 확장

* [**Markdown Image** by hancel.org](https://marketplace.visualstudio.com/items?itemName=hancel.markdown-image)
* Paste Image보다 강력한 버전으로,
  **이미지 업로드 대상**을 GitHub, Gitee, Imgur, SM.MS, Qiniu 등으로 설정 가능.
* 즉, GitHub Issues처럼 "이미지를 자동 업로드하고 링크 삽입"까지 가능함.

### 예시: GitHub 이미지 업로드 설정

1. GitHub Personal Access Token을 발급받고,
2. `settings.json`에 다음을 추가:

   ```json
   {
     "markdown-image.uploadMethod": "github",
     "markdown-image.github.repo": "username/repository",
     "markdown-image.github.token": "ghp_your_token_here",
     "markdown-image.github.branch": "main",
     "markdown-image.github.path": "assets/images"
   }
   ```
3. 이제 이미지를 붙여넣으면:

   * 자동으로 repo에 업로드되고
   * 본문에는 `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/https://raw.githubusercontent.com/username/repository/main/assets/images/파일명.png)` 삽입됨.

---

## ✅ 방법 3. **로컬 파일 드래그 앤 드롭 자동 변환**

VS Code 기본으로는 **마크다운 편집기에서 파일을 드래그해도 자동 삽입되지 않음**.
하지만 다음 확장들이 그 기능을 지원함:

* [**Markdown Drop Image**](https://marketplace.visualstudio.com/items?itemName=lyonbot.markdown-drop-image)

  * 이미지 파일을 드래그하면 자동으로 지정 폴더에 복사 후, `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/상대경로)` 삽입.
  * Paste Image와 비슷하지만 **드래그 앤 드롭 전용**.

---

## 🧭 추천 조합

| 용도                    | 추천 확장               | 특징                         |
| ----------------------- | ----------------------- | ---------------------------- |
| 로컬 블로그나 문서 작성 | **Paste Image**         | 간편, 오프라인 작업 가능     |
| GitHub 업로드 자동화    | **Markdown Image**      | GitHub 이미지 링크 자동 생성 |
| 드래그 앤 드롭 UX 유지  | **Markdown Drop Image** | GitHub UX와 가장 유사        |

---

원하는 사용 방식이 어떤 쪽이야?

* 로컬에 저장만 하면 되는지
* GitHub처럼 **자동 업로드**도 하고 싶은지
  그에 따라 구체적인 설정 예시를 바로 만들어줄게.

</details>
<br>

알맞는 플러그인을 찾아준 것 같긴 한데, 이미 같은 경로에 저장한 그림 파일을 마크다운 안에 넣으려고 하면 파일을 한번 더 생성한다.

아래의 질문을 던져서 해결해보자.

`Paste Image로 이미지를 넣는 과정에서 문제가 있어. 마크다운 파일과 같은 경로에 있는 이미지 파일을 복사-붙여넣기로 넣을 때 Paste Image가 동일한 이미지 파일을 하나 더 만들어버린다는 거야. 어떻게 할까?`

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

네, 아주 정확하고 중요한 포인트를 짚어주셨습니다! 그 문제는 `Paste Image` 확장의 동작 방식을 이해하면 쉽게 해결할 수 있습니다.

### 문제의 원인: 왜 파일이 복제될까요?

`Paste Image` 확장은 **클립보드에 있는 '이미지 데이터' 자체**를 가져와서 새로운 파일로 만드는 데 특화되어 있습니다.

사용자께서 파일 탐색기에서 이미지 파일(`my-image.png`)을 복사(`Ctrl+C`)하면, 클립보드에는 두 가지 정보가 모두 들어갑니다.

1.  파일의 **경로 정보** (`C:\project\images\my-image.png`)
2.  이미지 파일의 **실제 픽셀 데이터** (그림판에서 그림을 복사한 것과 동일)

이때 `Paste Image`의 단축키(`Ctrl+Alt+V`)를 누르면, 확장은 1번(경로 정보)은 무시하고 2번(**이미지 데이터**)을 가져옵니다. 그리고는 "아, 새로운 이미지 데이터가 들어왔구나! 이걸 설정된 경로에 새 파일로 저장해야지!"라고 판단하여 `2023-10-27-12-00-00.png`와 같은 새 파일을 만들어버리는 것입니다.

즉, **`Paste Image`는 기존 파일의 링크를 거는 용도가 아니라, 새로운 이미지를 프로젝트 안으로 가져와 저장하는 용도**에 최적화되어 있습니다.

---

### 해결 방법: 상황에 맞는 올바른 도구 사용하기

가장 좋은 해결책은 "무엇을 하고 싶은가?"에 따라 다른 방법을 사용하는 것입니다.

#### **해결책 1: [가장 추천] 기존 파일 링크는 '드래그 앤 드롭' 사용**

프로젝트 폴더 내에 **이미 있는 이미지 파일**을 마크다운에 삽입하고 싶을 때는 `Paste Image`를 사용하지 마세요. 대신 VS Code의 **내장 드래그 앤 드롭 기능**을 사용하는 것이 가장 직관적이고 올바른 방법입니다.

1.  VS Code의 탐색기(Explorer) 패널을 엽니다.
2.  삽입하려는 이미지 파일을 찾습니다.
3.  그 파일을 마크다운 편집기의 원하는 위치로 **마우스로 끌어다 놓습니다(Drag and Drop)**.
4.  그러면 VS Code가 자동으로 `![my-image](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/images/my-image.png)`와 같이 올바른 상대 경로의 마크다운 링크를 생성해 줍니다. **파일 복제는 절대 일어나지 않습니다.**



#### **해결책 2: '상대 경로 복사' 후 수동으로 링크 만들기**

드래그 앤 드롭이 번거롭다면, 키보드 중심으로 작업하는 방법입니다.

1.  VS Code 탐색기에서 이미지 파일을 **마우스 오른쪽 버튼으로 클릭**합니다.
2.  **'상대 경로 복사(Copy Relative Path)'**를 선택합니다. (`images/my-image.png` 와 같은 텍스트가 복사됩니다.)
3.  마크다운 편집기에서 `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/)`를 입력하고 괄호 안에 붙여넣기(`Ctrl+V`) 합니다.
    *   결과: `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/images/my-image.png)`

#### **해결책 3: 일반 붙여넣기(`Ctrl+V`) 시도해보기**

`Paste Image`의 전용 단축키(`Ctrl+Alt+V`) 대신, 그냥 일반 붙여넣기(`Ctrl+V`)를 시도해 보세요. VS Code의 내장 붙여넣기 기능은 파일 경로를 인식하여 링크를 만들어 줄 수 있습니다. (단, 이 동작은 다른 설정이나 확장의 영향을 받을 수 있습니다.)

---

### 최종 워크플로우 추천

이 두 가지 시나리오를 구분해서 사용하시면 앞으로 혼란 없이 매우 편리하게 작업하실 수 있습니다.

1.  **새로운 이미지** (웹, 스크린샷 캡처 등)를 마크다운에 추가할 때
    *   이미지를 클립보드에 복사 (`Ctrl+C` 또는 `PrtSc`)
    *   마크다운 편집기에서 **`Paste Image` 단축키 (`Ctrl+Alt+V`)** 사용
    *   ➡️ 자동으로 `images` 폴더에 파일이 저장되고 링크가 생성됩니다.

2.  **프로젝트 내에 이미 있는 이미지**를 마크다운에 링크할 때
    *   VS Code 탐색기에서 해당 이미지 파일을 **드래그 앤 드롭**
    *   ➡️ 파일 복제 없이 정확한 상대 경로 링크만 생성됩니다.

이렇게 역할 분담을 해서 사용하시는 것이 가장 효율적이고 의도한 대로 동작하게 하는 최고의 방법입니다.

</details>

### GPT-5의 결과물


<details markdown="1">
<summary>접기/펴기</summary>

아주 좋은 문제 제기야 👀
이건 **Paste Image 확장(Paste Image by mushan)** 을 실제로 써보면 많은 사람들이 겪는 대표적인 이슈야.

요약하자면:

> “마크다운 파일과 같은 경로(또는 지정 폴더)에 **이미 존재하는 이미지 파일을 복사해서 붙여넣을 때**, Paste Image가 또다시 그 파일을 복제해 새 파일명으로 저장한다.”

즉, “이미지 경로를 그대로 링크하지 않고, 무조건 새 파일을 생성”하는 동작이 문제지.

---

## 💡 원인

Paste Image는 클립보드에 들어있는 **이미지 데이터 비트맵**을 붙여넣는 도구야.
즉, ‘파일 경로’를 붙여넣는 게 아니라,
윈도우 클립보드에 있는 **실제 이미지 자체**(bitmap stream)를 받아 새 파일로 만들어버림.

그래서:

* 클립보드에 “파일 경로”로 복사된 이미지(예: Ctrl+C on a file)라도,
  Paste Image는 그걸 “파일 데이터”로 간주하고 새로 저장함.
* “이미 존재하는 파일을 참조하려는” 의도는 감지하지 못함.

---

## ✅ 해결 방향 3가지

### 🔹 방법 1. **파일 경로를 복사해 직접 링크로 삽입**

Paste Image를 끄고, 기존 파일 경로를 직접 삽입하는 방식으로 전환.

#### 1. Paste Image를 임시 비활성화

`Ctrl+Shift+P → Preferences: Open Keyboard Shortcuts (JSON)`
에서 아래처럼 단축키를 없애면 실수 방지 가능:

```json
{
  "key": "ctrl+alt+v",
  "command": "-pasteImage.pasteImage"
}
```

#### 2. 파일 탐색기에서 “파일 경로 복사”

윈도우 탐색기에서 파일을 Shift+우클릭 → “경로 복사”
→ VS Code에서

```markdown
![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/image.png)
```

이런 식으로 직접 넣기.

이건 수동이지만, 가장 명확하고 중복 생성이 없음.

---

### 🔹 방법 2. **Paste Image에 “기존 파일 사용 로직” 추가 (사용자 스크립트)**

Paste Image는 설정에 `"pasteImage.customOutputPath"`라는 고급 옵션이 있어.
이걸 이용해 “이미 동일 파일명이 존재하면 복사하지 않고 참조만 하도록” 커스텀 스크립트를 걸 수 있어.

예시 (`settings.json`):

```json
{
  "pasteImage.path": "${currentFileDir}",
  "pasteImage.customOutputPath": "${currentFileDir}/${imageFileName}",
  "pasteImage.insertPattern": "![${imageFileNameWithoutExt}](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/${imageFilePath})",
  "pasteImage.namePrefix": "",
  "pasteImage.nameSuffix": "",
  "pasteImage.defaultName": "image",
  "pasteImage.showFilePathConfirmInputBox": false,
  "pasteImage.customOutputPathConfirm": false
}
```

👉 그다음, `.vscode/paste-image.js` 파일을 만들어 아래처럼 작성:

```js
const fs = require("fs");
const path = require("path");

module.exports = {
  getTargetPath: function (srcPath, destDir, imageFileName) {
    const targetPath = path.join(destDir, imageFileName);
    // 파일이 이미 존재하면 복사하지 않음
    if (fs.existsSync(targetPath)) {
      console.log(`Image already exists: ${targetPath}`);
      return null; // null을 반환하면 Paste Image가 새 파일을 만들지 않음
    }
    return targetPath;
  }
};
```

이렇게 하면 Paste Image가 이미지를 붙여넣을 때
같은 이름의 파일이 있으면 새 파일을 만들지 않고 기존 파일 경로만 마크다운에 삽입해 줘.

---

### 🔹 방법 3. **다른 확장 사용 — “Markdown Drop Image”**

Paste Image는 붙여넣기 전용이라 어쩔 수 없이 새로 저장하지만,
[**Markdown Drop Image**](https://marketplace.visualstudio.com/items?itemName=lyonbot.markdown-drop-image)는
드래그 앤 드롭 시 “이미지 경로 그대로 삽입”이 가능함.

즉,

* 로컬 파일을 마크다운으로 드래그 → `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/파일이름.png)` 자동 입력
* 기존 파일을 복제하지 않음

Paste Image보다 가볍고, 네 시나리오(같은 폴더 내 기존 파일 참조)에 더 잘 맞을 수 있어.

---

## 🧭 추천 결론

| 목표                                                  | 해결책                                                         |
| ----------------------------------------------------- | -------------------------------------------------------------- |
| **이미 존재하는 이미지 파일 참조만 하고 싶다**        | 방법 3️⃣ “Markdown Drop Image” 사용                              |
| **클립보드에서 새 이미지 캡처 후 붙여넣기만 쓸 거다** | Paste Image 그대로 사용                                        |
| **둘 다 쓰고 싶다**                                   | Paste Image + Markdown Drop Image 병행, 단축키만 구분해서 사용 |

---

원하는 흐름이

> “마크다운 파일과 같은 폴더 안에 있는 이미지를 복사해서 붙여넣으면 그냥 `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/파일이름.png)`만 삽입되면 좋겠다”

맞지?
그럼 그에 맞춰 **Markdown Drop Image 설정 예시**까지 바로 만들어줄게 — 괜찮을까?

</details>
<br>

Paste Image 플러그인의 설정을 바꾸는 방법들을 추천받았는데 깔끔하게 동작하지 않는다.

심지어 GPT의 방법 3은 할루시네이션 현상 같다.

차라리 VS Code의 기본 기능 쪽을 더 파보는 게 나으려나? 다른 플러그인들을 찾아봐도 마땅한 수가 없어보이니 제미니에게 질문을 이어가보자.

`최신 버전의 VS Code에서 이미지 파일 드래그 앤 드롭을 했더니 에디터에서 열리는 문제가 있어.`

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

아, 네! 정확합니다. 최신 VS Code 버전에서 기본 동작이 그렇게 변경되었습니다. 아주 좋은 질문입니다.

결론부터 말씀드리면, 링크를 삽입하는 동작을 원하실 때는 **`Shift` 키를 누른 상태로 드래그 앤 드롭**하시면 됩니다.

---

### 자세한 설명과 이유

VS Code의 드래그 앤 드롭 동작은 두 가지로 나뉩니다.

1.  **기본 동작 ( 그냥 드래그 앤 드롭 )**: 파일을 에디터 영역으로 끌어다 놓으면, 해당 파일을 **새 탭에서 여는 것**이 기본 동작입니다. 이는 마크다운 파일뿐만 아니라 모든 종류의 파일에 동일하게 적용됩니다. (예: `.js` 파일을 끌어다 놓으면 해당 JS 파일이 열림)

2.  **대체 동작 ( `Shift` + 드래그 앤 드롭 )**: `Shift` 키는 "기본 동작 대신 이 파일 형식에 맞는 다른 동작을 수행해줘"라는 신호를 보냅니다.
    *   마크다운(`.md`) 파일이 활성화된 상태에서 이미지 파일을 `Shift` 키와 함께 끌어다 놓으면, VS Code는 "아, 이 사용자는 이미지를 열려는 게 아니라 마크다운에 **이미지 링크를 삽입**하려는 거구나!"라고 인식합니다.
    *   그 결과, 파일이 열리는 대신 마크다운 편집기에 `![image](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/images/image.png)` 와 같은 링크가 삽입됩니다.

### 올바른 사용법 (Step-by-Step)

1.  VS Code 탐색기에서 삽입하고 싶은 이미지 파일을 찾습니다.
2.  해당 파일을 마우스로 클릭해서 끌기 시작합니다.
3.  마크다운 에디터 창 위로 마우스를 가져온 후, **키보드의 `Shift` 키를 누릅니다.**
4.  `Shift` 키를 누른 상태에서 마우스 버튼을 놓아 파일을 드롭합니다.
5.  짜잔! 파일이 열리는 대신 마크다운 이미지 링크가 삽입됩니다.

### 만약 `Shift`를 눌러도 안 된다면? (설정 확인)

혹시라도 이 기능이 동작하지 않는다면, 관련 설정이 꺼져 있을 수 있습니다.

1.  `Ctrl + ,`를 눌러 설정(Settings)을 엽니다.
2.  검색창에 `markdown drop` 이라고 검색합니다.
3.  **`Markdown > Editor: Drop: Enabled`** 설정이 **체크되어 있는지 확인**합니다. (기본값은 체크되어 있습니다.)

이 설정은 마크다운 편집기에서 파일 드롭 시 링크를 생성하는 기능 자체를 켜고 끄는 역할을 합니다.

---

### 최종 워크플로우 정리

이제 두 가지 강력한 도구를 완벽하게 구분해서 사용하실 수 있습니다.

| 상황                                                     | 사용할 기능           | 방법                                         |
| :------------------------------------------------------- | :-------------------- | :------------------------------------------- |
| **1. 외부 이미지(웹, 캡처)를 프로젝트에 새로 추가할 때** | **Paste Image** 확장  | 이미지를 클립보드에 복사 후 `Ctrl+Alt+V`     |
| **2. 프로젝트 내에 이미 있는 파일을 링크할 때**          | **VS Code 내장 기능** | 탐색기에서 파일 **`Shift` + 드래그 앤 드롭** |

이렇게 구분해서 사용하시면 파일을 중복 생성하는 일 없이, 의도한 대로 정확하고 빠르게 이미지를 삽입하실 수 있습니다.

</details>
<br>

Shift 키를 사용해서 이미지 드래그 앤 드롭을 사용하면 일단 원하는 동작으로 작동은 한다.

기본 동작을 마크다운에 이미지 넣기로 변경하는 건 VS Code에서 불가능하다고 하니 어쩔 수 없나...

이제 기존의 글쓰기 유틸을 수정해서 draft를 폴더 단위로 나누고, 포스트를 발행할 때 이미지 파일들은 cdn 링크에서 해당 포스트의 이름을 가진 폴더에 넣게 바꾸자.

LLM으로 날로 먹을 수 있으면 좋겠는데.

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

네, 아주 훌륭하고 전문적인 아이디어입니다! 이 방식은 다음과 같은 큰 장점들을 가집니다.

*   **완벽한 독립성**: 각 포스트가 자신만의 폴더 안에서 글과 이미지를 모두 가지므로 개발 환경(로컬)에서 관리가 매우 편합니다. 마크다운 편집기에서 `./image.png`와 같이 아주 간단한 상대 경로로 이미지를 미리 보면서 작업할 수 있습니다.
*   **CDN 최적화**: 발행 시 이미지는 `cdn/img`와 같은 특정 경로로 분리되므로, 나중에 이 폴더만 CDN(Content Delivery Network)에 연결하여 웹사이트의 이미지 로딩 속도를 크게 향상시킬 수 있습니다.
*   **자동화의 극대화**: 글을 쓰는 사람은 복잡한 경로 변환을 신경 쓸 필요 없이, 스크립트가 발행 시점에 모든 이미지 경로를 자동으로 수정해 줍니다.

이 아이디어를 반영하여 `cli.js`를 대폭 개선해 보겠습니다. 가장 핵심적인 부분은 **`publishDraft` 함수 내에서 마크다운 파일의 내용을 읽고, 정규표현식(Regex)을 사용해 이미지 경로를 동적으로 변경한 후, 새 위치에 저장하는 로직**입니다.

---

### 수정된 `cli.js` 코드

#### 1. 상수 추가

CDN 이미지 경로를 위한 상수를 추가합니다.

```javascript
// ...
const POSTS_DIR = '_posts';
const TABS_DIR = '_tabs';
const CDN_IMG_DIR = path.join('cdn', 'img'); // <<< 추가
const CONFIG_PATH = 'config.json';
const git = simpleGit();
// ...
```

#### 2. `createDraft()` 함수 수정

초안 생성 시, 마크다운 파일을 담을 폴더를 생성하고 그 안에 파일을 넣도록 구조를 변경합니다.

```javascript
async function createDraft() {
  // ... inquirer.prompt 부분은 동일 ...

  const { title, categories, tags } = answers;

  const date = getFormattedDate();
  const slug = slugify(title);
  
  // --- 여기부터 수정 ---
  const draftDirName = `${date}-${slug}`; // 예: 2023-10-27-my-new-post
  const draftDirPath = path.join(DRAFTS_DIR, draftDirName); // 예: _drafts/2023-10-27-my-new-post
  
  const fileName = `${draftDirName}.md`;
  const filePath = path.join(draftDirPath, fileName);

  const fileContent = `---
title: ${title}
date: ${getFullDateTime()}
categories: [${categories.join(', ')}]
tags: [${tags.join(', ')}]
---

`;

  // 초안을 담을 폴더를 생성 (부모인 _drafts가 없어도 생성)
  if (!fs.existsSync(draftDirPath)) {
    fs.mkdirSync(draftDirPath, { recursive: true });
    console.log(`📁 초안 폴더를 생성했습니다: ${draftDirPath}`);
  }

  fs.writeFileSync(filePath, fileContent);
  console.log(`✅ 초안 파일이 성공적으로 생성되었습니다: ${filePath}`);
  
  // 사용자에게 이미지 관리 방법 안내
  console.log(
    `💡 이미지는 '${draftDirPath}' 폴더 안에 넣고, 마크다운에서는 './이미지.png' 와 같이 상대 경로로 사용하세요.`
  );
}
```

**수정된 부분 설명:**

*   이제 초안은 `_drafts` 폴더 바로 아래에 `.md` 파일로 생성되는 대신, **자신의 이름을 가진 폴더 안에 생성**됩니다.
*   사용자에게 이미지를 해당 폴더에 넣고, 간단한 상대 경로(`./`)를 사용하라고 안내합니다.

#### 3. `publishDraft()` 함수 대폭 수정

이 부분이 가장 많이 변경됩니다. 파일 이동, 경로 변환, 자원 분리 등 복잡한 로직이 추가됩니다.

```javascript
async function publishDraft() {
  if (!fs.existsSync(DRAFTS_DIR)) {
    console.log('🤷 초안 폴더가 없습니다. 먼저 draft 명령어로 글을 생성하세요.');
    return;
  }

  // 이제 파일이 아닌 폴더를 기준으로 초안 목록을 가져옵니다.
  const draftDirs = fs.readdirSync(DRAFTS_DIR, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  if (draftDirs.length === 0) {
    console.log('🤷 발행할 초안이 없습니다.');
    return;
  }

  const { dirToPublish } = await inquirer.prompt([
    {
      type: 'list',
      name: 'dirToPublish',
      message: '🚀 발행할 초안 폴더를 선택하세요:',
      choices: draftDirs
    }
  ]);

  const sourceDraftDir = path.join(DRAFTS_DIR, dirToPublish); // 예: _drafts/2023-10-27-slug
  const mdFileName = `${dirToPublish}.md`;
  const sourceMdPath = path.join(sourceDraftDir, mdFileName);
  
  // 목적지 경로 설정
  const destMdPath = path.join(POSTS_DIR, mdFileName);
  const destCdnDir = path.join(CDN_IMG_DIR, dirToPublish);

  // 1. 초안 폴더 내 파일 목록 읽기 (이미지 등)
  const allFiles = fs.readdirSync(sourceDraftDir);
  const assetFiles = allFiles.filter(file => file !== mdFileName);

  // 2. 마크다운 파일 내용 읽기 및 경로 변환
  if (!fs.existsSync(sourceMdPath)) {
    console.error(`❌ 오류: 마크다운 파일(${sourceMdPath})을 찾을 수 없습니다.`);
    return;
  }
  const originalContent = fs.readFileSync(sourceMdPath, 'utf-8');
  
  // 정규식: 상대 경로 이미지 링크 (![...](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/...))를 찾아서 변경
  const imagePathRegex = /!\[(.*?)\]\(\s*(\.\/|\.\.\/)?(.*?)\s*\)/g;
  const newCdnPathPrefix = `/${CDN_IMG_DIR.replace(/\\/g, '/')}/${dirToPublish}`;

  const newContent = originalContent.replace(imagePathRegex, `![$1](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/${newCdnPathPrefix}/$3)`);

  // 3. 목적지 폴더 생성
  if (!fs.existsSync(POSTS_DIR)) fs.mkdirSync(POSTS_DIR);
  if (assetFiles.length > 0 && !fs.existsSync(destCdnDir)) {
    fs.mkdirSync(destCdnDir, { recursive: true });
  }
  
  // 4. 경로가 수정된 마크다운 파일을 _posts로 쓰기
  fs.writeFileSync(destMdPath, newContent);
  console.log(`✅ 마크다운 파일 발행 완료: ${destMdPath}`);

  // 5. 이미지 파일들을 cdn/img 폴더로 이동
  for (const asset of assetFiles) {
    const sourceAssetPath = path.join(sourceDraftDir, asset);
    const destAssetPath = path.join(destCdnDir, asset);
    fs.renameSync(sourceAssetPath, destAssetPath);
  }
  if (assetFiles.length > 0) {
    console.log(`🖼️  이미지 파일들을 이동했습니다: ${destCdnDir}`);
  }

  // 6. 작업이 완료된 원본 초안 폴더 삭제
  fs.rmSync(sourceDraftDir, { recursive: true, force: true });
  console.log(`🗑️  원본 초안 폴더를 삭제했습니다: ${sourceDraftDir}`);

  // 7. Git 작업
  try {
    console.log('📦 Git에 변경사항을 커밋하고 푸시합니다...');
    gitConfig();

    await git.add(destMdPath); // 수정된 마크다운 파일 추가
    if (assetFiles.length > 0) {
      await git.add(destCdnDir); // 이미지 폴더 추가
    }
    
    await git.commit(`feat: publish new post - ${dirToPublish}`);
    await git.push();

    console.log('🎉 포스트 발행이 성공적으로 완료되었습니다!');
  } catch (error) {
    // ... 에러 처리 부분은 동일
  }
}
```

### 새로운 워크플로우 요약

1.  **`draft` 실행**:
    *   `_drafts/YYYY-MM-DD-slug` 폴더 생성.
    *   그 안에 `YYYY-MM-DD-slug.md` 파일 생성.
    *   사용자는 이 폴더 안에 이미지들을 넣고, 마크다운에서는 `./my-image.png`처럼 간단한 상대 경로로 글을 작성.

2.  **`publish` 실행**:
    *   사용자는 발행할 초안 **폴더**를 선택.
    *   스크립트는 `YYYY-MM-DD-slug.md` 파일의 내용을 읽음.
    *   정규식을 이용해 `![alt](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/my-image.png)`와 같은 모든 이미지 경로를 `![alt](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까//cdn/img/YYYY-MM-DD-slug/my-image.png)`와 같은 최종 CDN 경로로 **자동 변경**.
    *   경로가 변경된 새 마크다운 파일 내용을 `_posts/YYYY-MM-DD-slug.md` 경로에 저장.
    *   원본 초안 폴더에 있던 이미지 파일들을 `cdn/img/YYYY-MM-DD-slug/` 폴더로 **이동**.
    *   작업이 끝난 원본 초안 폴더(`_drafts/YYYY-MM-DD-slug`)는 **삭제**.
    *   최종 결과물(`_posts`의 파일, `cdn/img`의 폴더)을 Git에 커밋하고 푸시.

이처럼 개선된 스크립트는 로컬에서의 편리한 작성 경험과 배포 시의 최적화된 구조라는 두 마리 토끼를 모두 잡는 매우 강력한 도구가 될 것입니다.

</details>

### GPT-5의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

좋아요. 🎯
지금 말씀하신 구조는 **작성 시의 편의성과 배포 시의 정돈된 이미지 관리**를 둘 다 잡는 아주 이상적인 설계입니다.

정리하자면 이렇게 됩니다 👇

---

## 🧱 목표 구조

### draft 단계

```
_drafts/
  2025-10-17-my-title/
    2025-10-17-my-title.md
    image1.png
    diagram.png
```

### publish 후

```
_posts/
  2025-10-17-my-title.md
cdn/
  img/
    2025-10-17-my-title/
      image1.png
      diagram.png
```

📌 추가 요구사항

* publish 시 마크다운 파일의 본문에서
  `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/image1.png)` → `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까//cdn/img/2025-10-17-my-title/image1.png)`
  형태로 **이미지 경로를 일괄 변경**
* `_drafts/폴더명` 전체를 `_posts`로 옮기지 않고,
  마크다운 파일만 `_posts`로 이동하고 이미지는 `cdn/img`로 이동

---

## 🔧 수정 개요

이 설계를 반영하려면 `cli.js`의 다음 부분을 수정해야 합니다:

| 함수             | 변경 내용                                                                                           |
| ---------------- | --------------------------------------------------------------------------------------------------- |
| `createDraft()`  | 초안 생성 시 `_drafts/<slug>/` 폴더를 만들고 그 안에 `.md` 생성                                     |
| `publishDraft()` | 이미지 폴더를 `cdn/img/<slug>/`로 이동시키고, 마크다운 내 이미지 경로를 업데이트 후 `_posts`로 이동 |

---

## ✅ 변경된 주요 코드 예시

아래는 핵심 부분만 보여주는 개선 예시입니다.

### 1️⃣ 초안 생성 시 폴더 구조 구성

```js
async function createDraft() {
  let config;
  try {
    config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (error) {
    console.error(`❌ 설정 파일(${CONFIG_PATH})을 읽을 수 없습니다.`);
    return;
  }

  const answers = await inquirer.prompt([
    { type: 'input', name: 'title', message: '📝 포스트 제목을 입력하세요:' },
    {
      type: 'checkbox',
      name: 'categories',
      message: '📂 카테고리를 선택하세요:',
      choices: config.categories
    },
    {
      type: 'checkbox',
      name: 'tags',
      message: '🏷️ 태그를 선택하세요:',
      choices: config.tags
    }
  ]);

  const { title, categories, tags } = answers;
  const date = getFormattedDate();
  const slug = slugify(title);
  const dirName = `${date}-${slug}`;
  const draftDir = path.join(DRAFTS_DIR, dirName);
  const filePath = path.join(draftDir, `${dirName}.md`);

  // 폴더 생성
  if (!fs.existsSync(draftDir)) {
    fs.mkdirSync(draftDir, { recursive: true });
    console.log(`📁 '${draftDir}' 폴더를 생성했습니다.`);
  }

  const fileContent = `---
title: ${title}
date: ${getFullDateTime()}
categories: [${categories.join(', ')}]
tags: [${tags.join(', ')}]
---

`;

  fs.writeFileSync(filePath, fileContent);
  console.log(`✅ 초안이 생성되었습니다: ${filePath}`);
}
```

이제 초안은 `_drafts/yyyy-mm-dd-slug/` 안에 들어가며,
그 폴더 안에 이미지를 자유롭게 넣을 수 있습니다.

---

### 2️⃣ publish 시 이미지 이동 + 경로 변경

```js
async function publishDraft() {
  const draftDirs = fs
    .readdirSync(DRAFTS_DIR)
    .filter((f) => fs.lstatSync(path.join(DRAFTS_DIR, f)).isDirectory());

  if (draftDirs.length === 0) {
    console.log('🤷 발행할 초안 폴더가 없습니다.');
    return;
  }

  const { dirToPublish } = await inquirer.prompt([
    {
      type: 'list',
      name: 'dirToPublish',
      message: '🚀 발행할 초안 폴더를 선택하세요:',
      choices: draftDirs
    }
  ]);

  const draftDir = path.join(DRAFTS_DIR, dirToPublish);
  const mdPath = path.join(draftDir, `${dirToPublish}.md`);
  const postPath = path.join(POSTS_DIR, `${dirToPublish}.md`);
  const cdnDir = path.join('cdn', 'img', dirToPublish);

  if (!fs.existsSync(mdPath)) {
    console.log('❌ 해당 폴더에 마크다운 파일이 없습니다.');
    return;
  }

  // 1️⃣ 이미지 폴더 이동 (md 제외 모든 파일)
  fs.mkdirSync(path.dirname(cdnDir), { recursive: true });
  fs.mkdirSync(cdnDir, { recursive: true });

  const files = fs.readdirSync(draftDir);
  for (const file of files) {
    if (file === `${dirToPublish}.md`) continue;
    fs.renameSync(path.join(draftDir, file), path.join(cdnDir, file));
  }

  // 2️⃣ 마크다운 내 이미지 경로 수정
  let content = fs.readFileSync(mdPath, 'utf-8');
  content = content.replace(
    /\!\[[^\]]*\]\(\.\/([^)]+)\)/g,
    (_, filename) => `![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까//cdn/img/${dirToPublish}/${filename})`
  );

  fs.writeFileSync(mdPath, content);

  // 3️⃣ 포스트 파일 이동
  if (!fs.existsSync(POSTS_DIR)) fs.mkdirSync(POSTS_DIR);
  fs.renameSync(mdPath, postPath);

  // 4️⃣ Git 커밋 및 푸시
  try {
    await gitConfig();
    await git.add([postPath, cdnDir]);
    await git.commit(`chore: publish ${dirToPublish}`);
    await git.push();
    console.log(`🎉 '${dirToPublish}' 포스트가 발행되었습니다!`);
  } catch (error) {
    console.error('❌ Git 작업 중 오류:', error.message);
  }

  // 5️⃣ 남은 빈 폴더 정리
  fs.rmdirSync(draftDir);
}
```

---

## 🧩 결과 예시

### 작성 시

```
_drafts/2025-10-17-my-title/
  ├─ 2025-10-17-my-title.md
  ├─ image1.png
  └─ chart.png
```

### 발행 후

```
_posts/
  └─ 2025-10-17-my-title.md
cdn/
  └─ img/
     └─ 2025-10-17-my-title/
         ├─ image1.png
         └─ chart.png
```

마크다운 내부는 이렇게 바뀝니다:

```diff
- ![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까/image1.png)
+ ![](/img/2025-10-19-어떻게-블로그에-그림을-깔끔하게-넣을까//cdn/img/2025-10-17-my-title/image1.png)
```

---

## ✅ 장점 요약

| 항목                   | 장점                                                  |
| ---------------------- | ----------------------------------------------------- |
| **작성 편의성**        | 각 draft 폴더 내에서 이미지 관리 → 복사/붙여넣기 간단 |
| **게시 구조의 청결함** | `_posts`에는 마크다운만, 이미지들은 CDN 폴더에 일원화 |
| **경로 충돌 방지**     | `cdn/img/<slug>`로 이름 충돌 없음                     |
| **자동 링크 변환**     | 수동 수정 필요 없음                                   |

---

원하신다면 이 구조를 반영한 전체 완성형 `cli.js`를
그대로 붙여넣어 실행할 수 있게 만들어드릴 수도 있습니다.
지금 이 방식으로 완성된 버전을 원하시나요?


</details>
<br>

제미니 2.5의 결과물을 사용하고 조금 고쳤더니 이제 새로 쓴 글에 이미지가 잘 나온다.

블로그 관련 큰 거 하나 해결. 

이제 그동안 커미션한 이미지들이나 블로그에 하나씩 올려볼까?

그 전에 블로그 사이드바 기능도 한번 만져봐야겠다.
