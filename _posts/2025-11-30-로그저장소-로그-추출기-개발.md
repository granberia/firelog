---
title: 로그저장소 로그 추출기 개발
date: 2025-11-30 08:44:43 +0900
categories: [개발]
tags: [개발, TRPG]
---


로그저장소에 있는 로그를 텍스트만 남겨서 다운로드하는 도구를 만들고 있다.

로그 html 파일을 정규식으로 정제하는 것보다 로그저장소에서 Ctrl+A를 한 뒤 메모장에 옮겨넣는 방식이 로그 추출에 편리해서 이 방법을 추출에도 쓸 것 같다.

Playwright를 사용해서 브라우저를 실행한 뒤 Ctrl+A를 해서 클립보드에 복사된 내용을 파일로 옮길 수 있을지 알아보자.

먼저 로그저장소에서 저장할 캠페인 이름을 골라야 하는데, 캠페인 이름 목록을 웹사이트상에서 어떻게 가져올지 보다가...

캠페인 이름을 누른 뒤 펼쳐지는 캠페인 하위 로그들로 보내는 엘리먼트에 a href가 걸린 게 아니라 click 이벤트로 특정 링크로 보낸다는 걸 알아냈다.

이러면 하위 로그들로 통하는 링크를 어떻게 하나씩 추출할까 고민하다가, 그냥 각 엘리먼트에 data attribute를 넣어 로그저장소를 재배포하는 걸로 해결.

이제 엘리먼트의 data attribute만으로 실제 로그가 표시되는 링크를 유추할 수 있다. 겸사겸사 캠페인 이름들에도 data-title을 넣어서 페이지에서 찾기 편하게 했다.

이번에도 제미니와 GPT를 이용해 쉽게 코딩해보고 싶다. 스펙을 정리해서 프롬프트를 만들어보자.

### 프롬프트

```
당신은 nodejs로 아래의 스펙을 만족하는 코드를 작성해야 합니다.

- Playwright와 inquirer를 사용해서 사용자가 선택한 웹 사이트의 내용을 가져오는 유틸리티 스크립트입니다.
- Playwright로 실행된 브라우저가 작동하는 과정을 사용자가 볼 수 있어야 합니다.
- https://morgrave.github.io/xperion/ 링크의 사이트에 접속해서 사이트 로딩이 끝나면 data-title 을 가진 엘리먼트들의 목록을 가져옵니다.
- data-title 중 사용자가 원하는 data-title을 선택하게 합니다.
- 사용자가 선택한 data-title이 있는 엘리먼트를 클릭해서 사이드바가 확정되기를 기다립니다.
- 페이지에서 data-group 을 가진 모든 엘리먼트의 목록을 추출합니다. 그 중 사용자가 선택한 data-title 값과 같은 data-parent 값을 가진 엘리먼트만 남깁니다.
- 남은 엘리먼트의 data-group 값과 data-index 값을 배열로 저장한 뒤 이 배열을 순회하며 각 페이지에서 작업을 시작할 것입니다.
- 순회해야 하는 사이트는 https://morgrave.github.io/xperion/viewer/{data-group}/{data-index} 입니다.
- 브라우저의 가로 크기를 700px로 줄입니다.
- 배열 안에 있는 값들로 링크를 순회하며 아래의 동작을 수행합니다.
  - 페이지의 로딩이 끝나기까지 기다린 뒤 Ctrl + A 를 수행한 뒤 Ctrl + C 를 수행해서 전체 내용을 복사합니다.
  - 클립보드에 복사된 내용을 로컬 폴더의 expiriment/log/{data-group}/{data.index}.html 로 저장합니다.
  - 저장을 마쳤다면 다음 링크로 이동합니다.
- 모든 과정을 사용자가 인식하기 쉽도록 로그로 남겨야 합니다.
```

이제 LLM들이 어떻게 마법을 부리는지 확인해보자.

### 제미니 3 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

```javascript
import { chromium } from 'playwright';
import inquirer from 'inquirer';
import fs from 'fs';
import path from 'path';

/**
 * 로그 출력 유틸리티
 */
const log = (msg) => console.log(`[LOG] ${msg}`);

/**
 * 메인 실행 함수
 */
async function run() {
  log('스크립트를 시작합니다.');

  // 1. 브라우저 실행 (headless: false -> 작동 과정 보임)
  // 클립보드 접근 권한을 위해 permissions 설정 필요
  const browser = await chromium.launch({
    headless: false,
    args: ['--start-maximized'], // 필요 시 창 최대화
  });

  const context = await browser.newContext({
    permissions: ['clipboard-read', 'clipboard-write'], // 클립보드 읽기/쓰기 권한 부여
  });

  const page = await context.newPage();

  try {
    // 2. 사이트 접속
    const targetUrl = 'https://morgrave.github.io/xperion/';
    log(`사이트에 접속 중입니다: ${targetUrl}`);
    await page.goto(targetUrl, { waitUntil: 'networkidle' });

    // 3. data-title 엘리먼트 목록 가져오기
    log('data-title 엘리먼트 목록을 가져옵니다.');
    // 중복 제거를 위해 Set 사용 후 배열 변환
    const titles = await page.$$eval('[data-title]', (elements) => {
      const titleSet = new Set();
      elements.forEach((el) => {
        const title = el.getAttribute('data-title');
        if (title) titleSet.add(title);
      });
      return Array.from(titleSet);
    });

    if (titles.length === 0) {
      throw new Error('data-title을 가진 엘리먼트를 찾을 수 없습니다.');
    }

    // 4. Inquirer로 사용자 선택 받기
    const answer = await inquirer.prompt([
      {
        type: 'list',
        name: 'selectedTitle',
        message: '작업을 진행할 Title을 선택해주세요:',
        choices: titles,
      },
    ]);
    const selectedTitle = answer.selectedTitle;
    log(`사용자 선택: ${selectedTitle}`);

    // 5. 선택한 data-title이 있는 엘리먼트 클릭 및 대기
    log(`${selectedTitle} 엘리먼트를 클릭하고 사이드바 확장을 기다립니다.`);
    // 해당 타이틀을 가진 첫 번째 요소를 클릭
    await page.click(`[data-title="${selectedTitle}"]`);
    
    // 사이드바 확장을 기다림 (명시적인 애니메이션 대기 혹은 시간 대기)
    // data-group 요소들이 로드될 때까지 잠시 대기 (안전을 위해 2초 대기)
    await page.waitForTimeout(2000);

    // 6. data-group 엘리먼트 추출 및 필터링
    log('조건에 맞는 data-group 엘리먼트를 추출합니다.');
    const targets = await page.$$eval(
      '[data-group]',
      (elements, title) => {
        return elements
          .filter((el) => el.getAttribute('data-parent') === title)
          .map((el) => ({
            group: el.getAttribute('data-group'),
            index: el.getAttribute('data-index'),
          }))
          .filter(item => item.group && item.index); // 값이 있는 것만 남김
      },
      selectedTitle
    );

    log(`총 ${targets.length}개의 대상 페이지를 찾았습니다.`);

    // 7. 브라우저 가로 크기 700px로 변경
    log('브라우저 뷰포트 너비를 700px로 조정합니다.');
    const viewportSize = page.viewportSize();
    await page.setViewportSize({
      width: 700,
      height: viewportSize ? viewportSize.height : 800,
    });

    // 8. 배열 순회하며 작업 수행
    for (let i = 0; i < targets.length; i++) {
      const { group, index } = targets[i];
      const viewUrl = `https://morgrave.github.io/xperion/viewer/${group}/${index}`;
      
      log(`[${i + 1}/${targets.length}] 페이지 이동: ${viewUrl}`);
      
      // 페이지 이동 및 로딩 대기
      await page.goto(viewUrl, { waitUntil: 'domcontentloaded' });
      // 확실한 로딩을 위해 잠시 대기
      await page.waitForTimeout(1000);

      // Ctrl + A, Ctrl + C 수행
      log('전체 선택(Ctrl+A) 및 복사(Ctrl+C) 수행 중...');
      
      // 포커스를 맞추기 위해 body 클릭
      await page.click('body');
      
      // 키보드 단축키 입력
      // Mac 사용자의 경우 Meta 키를 사용해야 할 수도 있으나, 요청사항인 Ctrl로 구현
      await page.keyboard.press('Control+A');
      await page.keyboard.press('Control+C');

      // 클립보드 내용 읽기
      const clipboardContent = await page.evaluate(() => navigator.clipboard.readText());
      
      if (!clipboardContent) {
        log('경고: 클립보드 내용이 비어있습니다.');
      }

      // 파일 저장 경로 설정 (expiriment/log/{data-group}/{data.index}.html)
      // 요청 스펙의 오타로 보이는 'expiriment'를 그대로 유지합니다.
      const saveDir = path.join(process.cwd(), 'expiriment', 'log', group);
      const savePath = path.join(saveDir, `${index}.html`);

      // 디렉토리 생성
      if (!fs.existsSync(saveDir)) {
        fs.mkdirSync(saveDir, { recursive: true });
      }

      // 파일 쓰기
      fs.writeFileSync(savePath, clipboardContent, 'utf8');
      log(`파일 저장 완료: ${savePath}`);
    }

    log('모든 작업이 완료되었습니다.');

  } catch (error) {
    console.error('[ERROR] 작업 중 오류 발생:', error);
  } finally {
    // 9. 브라우저 종료 (선택 사항, 확인을 위해 주석 처리하거나 닫을 수 있음)
    log('브라우저를 종료합니다.');
    await browser.close();
  }
}

run();
```

</details>

### GPT-5의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

```
#!/usr/bin/env node
const inquirer = require("inquirer");
const { chromium } = require("playwright");
const clipboard = require("clipboardy");
const fs = require("fs-extra");
const path = require("path");

const BASE_URL = "https://morgrave.github.io/xperion";

async function main() {
  console.log("🚀 Xperion Scraping Utility Started!");

  const browser = await chromium.launch({
    headless: false,  // 브라우저 동작 시각화
    slowMo: 50
  });

  const context = await browser.newContext({
    viewport: { width: 700, height: 900 }
  });
  const page = await context.newPage();

  console.log("🌐 사이트 접속 중...");
  await page.goto(BASE_URL, { waitUntil: "load" });

  console.log("📌 data-title 엘리먼트 목록 수집...");
  await page.waitForSelector("[data-title]");
  const titles = await page.$$eval("[data-title]", els => {
    return els.map(el => ({
      title: el.getAttribute("data-title"),
      index: el.getAttribute("data-index")
    }));
  });

  const userChoice = await inquirer.prompt([
    {
      type: "list",
      name: "selectedTitle",
      message: "원하는 data-title을 선택하세요:",
      choices: titles.map(t => t.title)
    }
  ]);

  const selectedTitle = userChoice.selectedTitle;
  console.log(`👉 선택됨: ${selectedTitle}`);

  console.log("🖱️ 해당 항목 클릭하여 사이드바 로딩 대기...");
  await page.click(`[data-title="${selectedTitle}"]`);
  await page.waitForTimeout(1000);

  console.log("🔍 data-group 수집...");
  const filtered = await page.$$eval("[data-group]", (els, selectedTitle) => {
    return els
      .filter(el => el.getAttribute("data-parent") === selectedTitle)
      .map(el => ({
        group: el.getAttribute("data-group"),
        index: el.getAttribute("data-index"),
        parent: el.getAttribute("data-parent")
      }));
  }, selectedTitle);

  console.log(`📦 총 ${filtered.length}개 페이지를 순회합니다.`);

  for (const item of filtered) {
    const url = `${BASE_URL}/viewer/${item.group}/${item.index}`;
    console.log(`🌍 페이지 이동: ${url}`);

    await page.goto(url, { waitUntil: "load" });
    await page.waitForTimeout(1000);

    console.log("📋 전체 내용 클립보드에 복사...");
    await page.keyboard.press("Control+A");
    await page.keyboard.press("Control+C");
    await page.waitForTimeout(300);

    const content = await clipboard.read();

    const saveDir = path.join("experiment", "log", item.group);
    await fs.ensureDir(saveDir);

    const filePath = path.join(saveDir, `${item.index}.html`);
    await fs.writeFile(filePath, content, "utf8");

    console.log(`💾 저장 완료: ${filePath}`);
  }

  console.log("🎉 모든 작업이 완료되었습니다.");
  await browser.close();
}

main().catch(err => {
  console.error("❌ 오류 발생:", err);
});
```

</details>
<br>

실행해보기 전 첫인상으로는 GPT가 조금 더 코드를 깔끔하게 짰다.

GPT가 제공한 결과를 기반으로 다운로드받은 로그에서 불필요한 부분을 제거하도록 만들었더니 잘 동작한다.
