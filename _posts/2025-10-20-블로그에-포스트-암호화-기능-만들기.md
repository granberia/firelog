---
title: 블로그에 포스트 암호화 기능 만들기
date: 2025-10-20 22:39:35 +0900
categories: [개발]
tags: [개발, 블로그]
image:
  path: /img/2025-10-20-블로그에-포스트-암호화-기능-만들기/image.png
  alt: "alt text"
---


블로그에 기록을 남기다 보면 민감한 개인정보가 들어간 내용을 남겨야 할 때도 생길 수 있다.

그럴 때를 위해 블로그에 암호화 및 복호화 기능을 추가하자.

CryptoJS의 AES 암호화 방식을 쓰게 한 뒤 포스트를 읽을 때 키를 입력해서 복호화하는 버튼을 넣는 식으로 구현하면 되겠지.

제미니에게 암호화 방법을 제안하고 어떻게 구현하는지 지켜보자.

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

알겠습니다. 제공해주신 `Chirpy` 테마의 `post.html` 레이아웃을 기반으로 암호화/복호화 기능을 완벽하게 통합한 코드를 작성해 드리겠습니다.

기존 레이아웃의 구조와 스타일을 그대로 유지하면서, 암호화된 포스트일 경우에만 본문 영역(`div.content`)을 동적으로 교체하는 방식으로 구현합니다.

### 수정된 `_layouts/post.html`

아래 코드를 기존 `_layouts/post.html` 파일의 내용과 통째로 바꾸시면 됩니다.

```html
---
layout: default
refactor: true
panel_includes:
  - toc
tail_includes:
  - related-posts
  - post-nav
script_includes:
  - comment
---

{% include lang.html %} {% include toc-status.html %}

<article class="px-1" data-toc="{{ enable_toc }}">
  <header>
    <h1 data-toc-skip>{{ page.title }}</h1>
    {% if page.description %}
    <p class="post-desc fw-light mb-4">{{ page.description }}</p>
    {% endif %}

    <div class="post-meta text-muted">
      <!-- ... 기존 header의 meta 정보는 그대로 유지 ... -->
      <span>
        {{ site.data.locales[lang].post.posted }} {% include datetime.html
        date=page.date tooltip=true lang=lang %}
      </span>
      {% if page.last_modified_at and page.last_modified_at != page.date %}
      <span>
        {{ site.data.locales[lang].post.updated }} {% include datetime.html
        date=page.last_modified_at tooltip=true lang=lang %}
      </span>
      {% endif %}
      <div class="d-flex justify-content-between">
        <span>
          {% if page.author %} {% assign authors = page.author %} {% elsif
          page.authors %} {% assign authors = page.authors %} {% endif %} {{
          site.data.locales[lang].post.written_by }}
          <em>
            {% if authors %} {% for author in authors %} {% if
            site.data.authors[author].url -%}
            <a href="{{ site.data.authors[author].url }}"
              >{{ site.data.authors[author].name }}</a
            >
            {%- else -%} {{ site.data.authors[author].name }} {%- endif %} {%
            unless forloop.last %}{{ '</em
          >,
          <em
            >' }}{% endunless %} {% endfor %} {% else %}
            <a href="{{ site.social.links[0] }}">{{ site.social.name }}</a>
            {% endif %}
          </em>
        </span>
        <div>
          {% if site.pageviews.provider and
          site.analytics[site.pageviews.provider].id %}
          <span>
            <em id="pageviews">
              <i class="fas fa-spinner fa-spin small"></i>
            </em>
            {{ site.data.locales[lang].post.pageview_measure }}
          </span>
          {% endif %}
          {% include read-time.html content=content prompt=true lang=lang %}
        </div>
      </div>
    </div>
  </header>
  
  {% comment %} ----- ▼▼▼ 암호화 로직 시작 ▼▼▼ ----- {% endcomment %}
  
  {% if page.encrypt %}
  <!-- [암호화된 포스트] -->
  <!-- TOC 관련 구조는 그대로 유지합니다. -->
  {% if enable_toc %}
    <div id="toc-bar" class="d-flex align-items-center justify-content-between invisible">
      <span class="label text-truncate">{{ page.title }}</span>
      <button type="button" class="toc-trigger btn me-1"><i class="fa-solid fa-list-ul fa-fw"></i></button>
    </div>
    <button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm">
      <span class="label ps-2 pe-1">{{- site.data.locales[lang].panel.toc -}}</span>
      <i class="fa-solid fa-angle-right fa-fw"></i>
    </button>
    <dialog id="toc-popup" class="p-0">
      <div class="header d-flex flex-row align-items-center justify-content-between">
        <div class="label text-truncate py-2 ms-4">{{- page.title -}}</div>
        <button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"><i class="fas fa-close"></i></button>
      </div>
      <div id="toc-popup-content" class="px-4 py-3 pb-4"></div>
    </dialog>
  {% endif %}

  <!-- 본문 영역을 복호화 UI로 교체 -->
  <div class="content">
    <div id="decryption-wrapper" class="text-center p-4 border rounded">
      <i class="fa-solid fa-lock fa-2x mb-3"></i>
      <p class="mb-3">이 포스트는 암호화되어 있습니다. 내용을 보려면 비밀번호를 입력하세요.</p>
      <div class="input-group mb-3 mx-auto" style="max-width: 300px;">
        <input type="password" id="password-input" class="form-control" placeholder="비밀번호" aria-label="Password">
        <button id="decrypt-button" class="btn btn-primary" type="button">확인</button>
      </div>
      <p id="error-message" class="text-danger small" style="display: none;">비밀번호가 올바르지 않습니다.</p>
    </div>
    <!-- 암호화된 본문을 Javascript에서 사용할 수 있도록 숨겨둡니다. -->
    <div id="encrypted-data" style="display:none;">{{ content }}</div>
    <!-- 복호화된 내용이 여기에 삽입됩니다. -->
    <div id="decrypted-content" style="display: none;"></div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      if (document.getElementById('decryption-wrapper')) {
        const decryptButton = document.getElementById('decrypt-button');
        const passwordInput = document.getElementById('password-input');
        const encryptedData = document.getElementById('encrypted-data').innerHTML.trim();
        
        const decryptAndDisplay = () => {
          const secretKey = passwordInput.value;
          const errorMessage = document.getElementById('error-message');
          
          if (!secretKey) return;

          try {
            const decryptedBytes = CryptoJS.AES.decrypt(encryptedData, secretKey);
            const decryptedText = decryptedBytes.toString(CryptoJS.enc.Utf8);
            
            if (decryptedText) {
              const decryptedContent = document.getElementById('decrypted-content');
              decryptedContent.innerHTML = decryptedText;
              
              document.getElementById('decryption-wrapper').style.display = 'none';
              decryptedContent.style.display = 'block';

              // Chirpy 테마의 TOC(Table of Contents) 스크립트를 수동으로 다시 초기화
              if (typeof window.toc !== 'undefined') {
                window.toc.init();
              }
            } else {
              throw new Error('Decryption resulted in empty content.');
            }
          } catch (e) {
            errorMessage.style.display = 'block';
            passwordInput.focus();
            console.error('Decryption failed:', e);
          }
        };

        decryptButton.addEventListener('click', decryptAndDisplay);
        passwordInput.addEventListener('keyup', (event) => {
          if (event.key === "Enter") {
            decryptButton.click();
          }
        });
      }
    });
  </script>

  {% else %}
  <!-- [일반 포스트] -->
  
    {% if enable_toc %}
      <div id="toc-bar" class="d-flex align-items-center justify-content-between invisible">
        <span class="label text-truncate">{{ page.title }}</span>
        <button type="button" class="toc-trigger btn me-1"><i class="fa-solid fa-list-ul fa-fw"></i></button>
      </div>
      <button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm">
        <span class="label ps-2 pe-1">{{- site.data.locales[lang].panel.toc -}}</span>
        <i class="fa-solid fa-angle-right fa-fw"></i>
      </button>
      <dialog id="toc-popup" class="p-0">
        <div class="header d-flex flex-row align-items-center justify-content-between">
          <div class="label text-truncate py-2 ms-4">{{- page.title -}}</div>
          <button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"><i class="fas fa-close"></i></button>
        </div>
        <div id="toc-popup-content" class="px-4 py-3 pb-4"></div>
      </dialog>
    {% endif %}

    <div class="content">{{ content }}</div>
  {% endif %}
  {% comment %} ----- ▲▲▲ 암호화 로직 종료 ▲▲▲ ----- {% endcomment %}

  <div class="post-tail-wrapper text-muted">
    <!-- ... 기존 post-tail-wrapper 내용 (categories, tags 등)은 그대로 유지 ... -->
    {% if page.categories.size > 0 %}
    <div class="post-meta mb-3">
      <i class="far fa-folder-open fa-fw me-1"></i>
      {% for category in page.categories %}
      <a href="{{ site.baseurl }}/categories/{{ category | slugify | url_encode }}/">{{ category }}</a>
      {%- unless forloop.last -%},{%- endunless -%} {% endfor %}
    </div>
    {% endif %}
    {% if page.tags.size > 0 %}
    <div class="post-tags">
      <i class="fa fa-tags fa-fw me-1"></i>
      {% for tag in page.tags %}
      <a href="{{ site.baseurl }}/tags/{{ tag | slugify | url_encode }}/" class="post-tag no-text-decoration">{{- tag -}}</a>
      {% endfor %}
    </div>
    {% endif %}
    <div class="post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2">
      <div class="license-wrapper">
        {% if site.data.locales[lang].copyright.license.template %} {% capture
        _replacement %}
        <a href="{{ site.data.locales[lang].copyright.license.link }}">
          {{ site.data.locales[lang].copyright.license.name }}
        </a>
        {% endcapture %} {{ site.data.locales[lang].copyright.license.template |
        replace: ':LICENSE_NAME', _replacement }} {% endif %}
      </div>
      {% include post-sharing.html lang=lang %}
    </div>
  </div>
</article>
```

### 주요 변경점 및 설명

1.  **전체 구조 분기**: `{% if page.encrypt %}` Liquid 태그를 사용하여 포스트의 Front Matter에 `encrypt: true`가 있는지 확인합니다.
    *   **True일 경우**: 암호화된 포스트를 위한 HTML과 Javascript를 렌더링합니다.
    *   **False일 경우 (또는 해당 변수가 없을 경우)**: 기존의 일반 포스트 HTML(`div.content` 포함)을 그대로 렌더링합니다.

2.  **중복 최소화**: 암호화 여부와 상관없이 동일하게 사용되는 `header`와 `post-tail-wrapper` 부분은 그대로 두고, 동적으로 변경되어야 하는 **본문 영역만 분기 처리**하여 코드의 중복을 최소화했습니다. TOC 관련 HTML은 양쪽 모두에 포함시켜 구조를 유지했습니다.

3.  **UI 개선**: 복호화 UI에 Bootstrap 클래스(`input-group`, `form-control`, `btn` 등)와 Font Awesome 아이콘을 사용하여 Chirpy 테마와 잘 어울리도록 디자인했습니다.

4.  **TOC(목차) 재초기화**:
    *   `Chirpy` 테마는 페이지 로드 시 Javascript로 목차(`TOC`)를 생성합니다.
    *   암호화된 포스트는 처음에는 본문이 없기 때문에 목차가 비어있게 됩니다.
    *   복호화에 성공하여 동적으로 본문(`decryptedText`)을 삽입한 후, `window.toc.init()`을 호출하여 **목차를 다시 생성**하도록 했습니다. 이 부분이 없으면 복호화 후에도 목차가 보이지 않습니다.

5.  **스크립트 실행 시점**: `DOMContentLoaded` 이벤트를 사용하여 HTML 문서가 모두 로드된 후에 복호화 관련 스크립트가 안전하게 실행되도록 했습니다.

### 최종 확인사항

1.  **`crypto-js` 라이브러리 로드**: 이 코드가 정상적으로 작동하려면, `_layouts/default.html` 또는 `_includes/head.html`에 아래 코드가 반드시 포함되어 있어야 합니다.
    ```html
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    ```

이제 이 레이아웃을 적용하면, `cli.js`를 통해 암호화하여 발행한 포스트는 웹에서 완벽하게 복호화 기능을 제공하게 됩니다.

네, 알겠습니다. 지금까지 논의된 모든 기능(포스트별 폴더 관리, 이미지 CDN 분리, 경로 자동 변환, 헤더 이미지 자동 추가, 선택적 암호화)과 주의사항을 종합하여 완성된 `cli.js` 코드를 제공해 드립니다.

각 기능이 올바른 순서로 실행되도록 `publishDraft` 함수 내부 로직을 신중하게 구성했습니다.

### 사전 준비 사항

1.  **필요한 라이브러리를 설치하세요.**
    ```bash
    npm install inquirer simple-git crypto-js
    ```

2.  **설정 파일을 생성하세요.**
    *   **`config.json`**: 카테고리 및 태그 목록을 정의합니다.
      ```json
      {
        "categories": ["Tech", "Life", "Programming"],
        "tags": ["Jekyll", "NodeJS", "Web", "Essay"]
      }
      ```
    *   **`password.json`**: 암호화에 사용할 키를 정의합니다.
      ```json
      {
        "keys": {
          "private": "my-super-secret-key-123",
          "friends_only": "another-password-for-friends"
        }
      }
      ```

---

### 최종 `cli.js` 코드

```javascript
#!/usr/bin/env node

/**
 * Jekyll 블로그 포스트 관리를 위한 CLI 유틸리티
 *
 * 기능:
 * 1. 새로운 초안 생성 (포스트별 폴더 구조)
 * 2. 초안 발행 (이미지 CDN 분리, 경로 자동 변환, 헤더 이미지 추가, 선택적 암호화)
 * 3. _tabs 폴더 내용 배포
 */

import inquirer from 'inquirer';
import fs from 'fs';
import path from 'path';
import simpleGit from 'simple-git';
import CryptoJS from 'crypto-js';

// --- 상수 정의 ---
const DRAFTS_DIR = '_drafts';
const POSTS_DIR = '_posts';
const TABS_DIR = '_tabs';
const CDN_IMG_DIR = path.join('cdn', 'img'); // 실제 파일이 저장될 물리적 경로
const URL_IMG_PREFIX = '/img'; // 마크다운에 삽입될 URL 경로 접두사
const CONFIG_PATH = 'config.json';
const PASSWORD_PATH = 'password.json';
const git = simpleGit();

// --- 도우미 함수 ---
async function gitConfig() {
  await git.addConfig('user.name', 'granberia');
  await git.addConfig('user.email', 'reptilesax@gmail.com');
}

function slugify(title) {
  return title.trim().replace(/\s+/g, '-').replace(/-+/g, '-');
}

function getFormattedDate() {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function getFullDateTime() {
  const date = new Date();
  const offset = -date.getTimezoneOffset();
  const offsetHours = String(Math.floor(Math.abs(offset) / 60)).padStart(2, '0');
  const offsetMinutes = String(Math.abs(offset) % 60).padStart(2, '0');
  const sign = offset >= 0 ? '+' : '-';

  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')} ${String(date.getHours()).padStart(2,'0')}:${String(date.getMinutes()).padStart(2,'0')}:${String(date.getSeconds()).padStart(2,'0')} ${sign}${offsetHours}${offsetMinutes}`;
}

// --- 핵심 기능 함수 ---

async function createDraft() {
  let config, passwords;
  try {
    config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'));
    passwords = JSON.parse(fs.readFileSync(PASSWORD_PATH, 'utf-8'));
    if (!passwords.keys || Object.keys(passwords.keys).length === 0) {
      throw new Error('password.json에 유효한 키가 없습니다.');
    }
  } catch (error) {
    console.error(`❌ 설정 파일 또는 비밀번호 파일을 읽을 수 없습니다: ${error.message}`);
    return;
  }

  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'title',
      message: '📝 포스트 제목을 입력하세요:',
      validate: (input) => (input ? true : '제목은 비워둘 수 없습니다.'),
    },
    {
      type: 'checkbox',
      name: 'categories',
      message: '📂 카테고리를 선택하세요:',
      choices: config.categories,
      validate: (input) => (input.length > 0 ? true : '하나 이상의 카테고리를 선택해야 합니다.'),
    },
    {
      type: 'checkbox',
      name: 'tags',
      message: '🏷️ 태그를 선택하세요:',
      choices: config.tags,
    },
    {
      type: 'confirm',
      name: 'isEncrypted',
      message: '🔒 이 포스트를 암호화하시겠습니까?',
      default: false,
    },
    {
      type: 'list',
      name: 'keyId',
      message: '🔑 사용할 암호화 키를 선택하세요:',
      choices: Object.keys(passwords.keys),
      when: (answers) => answers.isEncrypted,
    },
  ]);

  const { title, categories, tags, isEncrypted, keyId } = answers;

  const date = getFormattedDate();
  const slug = slugify(title);
  const draftDirName = `${date}-${slug}`;
  const draftDirPath = path.join(DRAFTS_DIR, draftDirName);
  const fileName = `${draftDirName}.md`;
  const filePath = path.join(draftDirPath, fileName);

  let frontMatter = `---
title: ${title}
date: ${getFullDateTime()}
categories: [${categories.join(', ')}]
tags: [${tags.join(', ')}]
`;

  if (isEncrypted) {
    frontMatter += `encrypt: true\nkey_id: ${keyId}\n`;
  }
  const fileContent = `${frontMatter}---\n\n`;

  fs.mkdirSync(draftDirPath, { recursive: true });
  console.log(`📁 초안 폴더를 생성했습니다: ${draftDirPath}`);

  fs.writeFileSync(filePath, fileContent);
  console.log(`✅ 초안 파일이 성공적으로 생성되었습니다: ${filePath}`);
  console.log(`💡 이미지는 '${draftDirPath}' 폴더 안에 넣고, 마크다운에서는 './이미지.png' 와 같이 상대 경로로 사용하세요.`);
}

async function publishDraft() {
  if (!fs.existsSync(DRAFTS_DIR)) {
    console.log('🤷 초안 폴더가 없습니다.');
    return;
  }
  const draftDirs = fs.readdirSync(DRAFTS_DIR, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);

  if (draftDirs.length === 0) {
    console.log('🤷 발행할 초안이 없습니다.');
    return;
  }

  const { dirToPublish } = await inquirer.prompt([{
    type: 'list',
    name: 'dirToPublish',
    message: '🚀 발행할 초안 폴더를 선택하세요:',
    choices: draftDirs,
  }]);

  const sourceDraftDir = path.join(DRAFTS_DIR, dirToPublish);
  const mdFileName = `${dirToPublish}.md`;
  const sourceMdPath = path.join(sourceDraftDir, mdFileName);
  
  const destMdPath = path.join(POSTS_DIR, mdFileName);
  const destCdnDir = path.join(CDN_IMG_DIR, dirToPublish);

  if (!fs.existsSync(sourceMdPath)) {
    console.error(`❌ 오류: 마크다운 파일(${sourceMdPath})을 찾을 수 없습니다.`);
    return;
  }

  // --- 포스트 내용 처리 (순서가 매우 중요) ---
  let originalContent = fs.readFileSync(sourceMdPath, 'utf-8');
  let contentForPublishing = originalContent;

  // 1. 헤더 이미지 추가
  const firstImageRegex = /!\[(.*?)\]\(\s*(\.\/)?(.*?)\s*\)/;
  const firstImageMatch = firstImageRegex.exec(contentForPublishing);

  if (firstImageMatch) {
    const altText = firstImageMatch[1].replace(/"/g, '\\"');
    const imageFileName = firstImageMatch[3];
    const headerImagePath = `${URL_IMG_PREFIX}/${dirToPublish}/${imageFileName}`;
    const imageFrontMatter = `image:\n  path: ${headerImagePath}\n  alt: "${altText}"\n`;

    const parts = contentForPublishing.split('---');
    contentForPublishing = `---${parts[1]}${imageFrontMatter}---${parts.slice(2).join('---')}`;
    console.log('✅ 헤더 이미지를 Front Matter에 추가했습니다.');
  }

  // 2. 본문 이미지 경로 전체 변환
  const imagePathRegex = /!\[(.*?)\]\(\s*(\.\/|\.\.\/)?(.*?)\s*\)/g;
  const newImagePathPrefix = `${URL_IMG_PREFIX}/${dirToPublish}`;
  contentForPublishing = contentForPublishing.replace(imagePathRegex, `![$1](${newImagePathPrefix}/$3)`);
  console.log('✅ 본문 이미지 경로를 최종 URL로 변경했습니다.');

  // 3. 암호화 (모든 내용 변경 후 마지막에 수행)
  let [_, frontMatterString, body] = contentForPublishing.split(/---(.*?)---/s);
  const isEncrypted = /encrypt:\s*true/.test(frontMatterString);
  
  if (isEncrypted) {
    const keyIdMatch = /key_id:\s*(.*)/.exec(frontMatterString);
    if (keyIdMatch) {
      const keyId = keyIdMatch[1].trim();
      try {
        const passwords = JSON.parse(fs.readFileSync(PASSWORD_PATH, 'utf-8'));
        const secretKey = passwords.keys[keyId];
        if (!secretKey) throw new Error(`'${keyId}' 키를 찾을 수 없습니다.`);
        
        body = CryptoJS.AES.encrypt(body.trim(), secretKey).toString();
        console.log('🔒 포스트 본문을 성공적으로 암호화했습니다.');
      } catch (error) {
        console.error(`❌ 암호화 중 오류 발생: ${error.message}`);
        return;
      }
    }
  }

  const finalContent = `---${frontMatterString}---\n${body}`;

  // --- 파일 시스템 작업 ---
  if (!fs.existsSync(POSTS_DIR)) fs.mkdirSync(POSTS_DIR);
  fs.writeFileSync(destMdPath, finalContent);
  console.log(`✅ 마크다운 파일 발행 완료: ${destMdPath}`);

  const assetFiles = fs.readdirSync(sourceDraftDir).filter((file) => file !== mdFileName);
  if (assetFiles.length > 0) {
    if (!fs.existsSync(destCdnDir)) fs.mkdirSync(destCdnDir, { recursive: true });
    for (const asset of assetFiles) {
      fs.renameSync(path.join(sourceDraftDir, asset), path.join(destCdnDir, asset));
    }
    console.log(`🖼️  이미지 파일들을 이동했습니다: ${destCdnDir}`);
  }

  fs.rmSync(sourceDraftDir, { recursive: true, force: true });
  console.log(`🗑️  원본 초안 폴더를 삭제했습니다: ${sourceDraftDir}`);

  // --- Git 작업 ---
  try {
    console.log('📦 Git에 변경사항을 커밋하고 푸시합니다...');
    await gitConfig();
    await git.add([destMdPath, destCdnDir]);
    await git.commit(`feat: publish new post - ${dirToPublish}`);
    await git.push();
    console.log('🎉 포스트 발행이 성공적으로 완료되었습니다!');
  } catch (error) {
    console.error('❌ Git 작업 중 오류가 발생했습니다:', error.message);
  }
}

async function updateTabs() {
  if (!fs.existsSync(TABS_DIR)) {
    console.log(`🤷 '${TABS_DIR}' 폴더가 존재하지 않습니다.`);
    return;
  }
  try {
    console.log(`📦 '${TABS_DIR}' 폴더의 변경사항을 배포합니다...`);
    await gitConfig();
    await git.add(TABS_DIR);
    await git.commit('chore: deploy tabs');
    await git.push();
    console.log(`🎉 '${TABS_DIR}' 폴더 배포가 성공적으로 완료되었습니다!`);
  } catch (error) {
    if (error.message.includes('nothing to commit')) {
      console.log('🤷 커밋할 변경사항이 없습니다.');
    } else {
      console.error('❌ Git 작업 중 오류가 발생했습니다:', error.message);
    }
  }
}

// --- 메인 실행 함수 ---
async function main() {
  const { action } = await inquirer.prompt([{
    type: 'list',
    name: 'action',
    message: '👋 안녕하세요! 무엇을 도와드릴까요?',
    choices: [
      { name: '새로운 초안 작성하기', value: 'draft' },
      { name: '초안을 포스트로 발행하기', value: 'publish' },
      { name: '전체 탭을 배포하기', value: 'update' },
      new inquirer.Separator(),
      { name: '종료', value: 'exit' },
    ],
  }]);

  switch (action) {
    case 'draft':
      await createDraft();
      break;
    case 'publish':
      await publishDraft();
      break;
    case 'update':
      await updateTabs();
      break;
    case 'exit':
      console.log('👋 다음에 또 만나요!');
      break;
  }
}

main();
```

</details>
<br>

Jekyll 블로그 포스트 전체의 레이아웃을 바꿔주려면 post.html을 수정하면 되는구나.

여기에 암호화 여부로 분기되게끔 처리하면 되는 것 같다.

그 과정에서 제미니가 Liquid 문법에 익숙하지 않은지 주석을 이상하게 넣었다가 아래왜 같은 참사가 벌어지기도 했지만...

![alt text](/img/2025-10-20-블로그에-포스트-암호화-기능-만들기/image.png)

이렇게 한 줄 뒤로 통째로 주석으로 바뀐다거나 하는 문제 외에도 복호화가 올바르게 되지 않아 원문이 손상되었나 확인하는 과정에서 아래와 같은 해결책도 적용해야 했다.

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

### : `jsonify` 필터 사용 및 `capture` 태그로 안정성 확보

잘못된 필터 이름을 바로잡는 것과 더불어, 한 단계 더 나아가 `capture`라는 Liquid 태그를 사용하여 이 과정을 더욱 안정적으로 만들겠습니다. `capture` 태그는 Liquid 처리 결과를 변수에 안전하게 담아주는 역할을 합니다.

#### 수정할 코드

**기존 코드:**
```javascript
const encryptedData = {{ content | strip_html | json }};
```

**★★★ 최종 수정 코드 ★★★**

`post.html`의 `<script>` 태그 **바로 위**와 **내부**를 아래와 같이 수정해주세요.

```html
<!-- ... 다른 HTML 코드 ... -->

{%- comment -%}
  1. content에서 HTML 태그와 앞뒤 공백을 모두 제거하고,
     그 결과를 'encrypted_string'이라는 변수에 저장합니다.
{%- endcomment -%}
{%- capture encrypted_string -%}{{ content | strip_html | strip }}{%- endcapture -%}

<script>
  document.addEventListener('DOMContentLoaded', () => {
    if (document.getElementById('decryption-wrapper')) {
      const decryptForm = document.getElementById('decrypt-form');
      const passwordInput = document.getElementById('password-input');
      
      // 2. 위에서 캡처한 변수를 'jsonify' 필터로 안전하게 출력합니다.
      const encryptedData = {{ encrypted_string | jsonify }};
      
      const decryptAndDisplay = () => {
        // ... 이하 복호화 로직은 동일 ...
// ... 이하 코드 동일 ...
```

### 왜 이렇게 해야 하는가?

1.  **`jsonify` 필터**: 이것이 Jekyll에서 문자열을 올바른 JSON 형식(큰따옴표로 감싸고 내부 특수문자를 이스케이프)으로 변환해주는 **올바른 필터**입니다.
2.  **`capture` 태그**: `<script>` 태그 안에서 복잡한 Liquid 필터 체인을 직접 사용하는 것은 때때로 예기치 않은 파싱 문제를 일으킬 수 있습니다. `capture`를 사용하면,
    *   먼저 스크립트 외부의 안전한 공간에서 **순수한 암호문 데이터**를 `encrypted_string`이라는 변수로 완벽하게 준비합니다.
    *   그런 다음 스크립트 내부에서는 이 준비된 변수를 `jsonify` 필터 하나만으로 깔끔하게 출력합니다.
    *   이는 코드의 가독성을 높이고 잠재적인 오류를 방지하는 매우 안정적인 방법입니다.
3.  **`strip` 필터 추가**: `strip_html`을 사용한 후 남아있을 수 있는 눈에 보이지 않는 줄바꿈 문자나 공백을 `strip` 필터로 한번 더 제거하여 데이터의 순수성을 보장합니다.

---

### 수정된 `_layouts/post.html` (진짜 최종 완성본)

아래는 이 모든 것이 적용된 코드입니다. 이제는 정말 확실하게 작동할 것입니다.

```html
---
layout: default
refactor: true
panel_includes:
  - toc
tail_includes:
  - related-posts
  - post-nav
script_includes:
  - comment
---

{% include lang.html %} {% include toc-status.html %}

<article class="px-1" data-toc="{{ enable_toc }}">
  <header>
    <!-- ... header content ... -->
    <h1 data-toc-skip>{{ page.title }}</h1>
    {% if page.description %}<p class="post-desc fw-light mb-4">{{ page.description }}</p>{% endif %}
    <div class="post-meta text-muted">
      <span>{{ site.data.locales[lang].post.posted }} {% include datetime.html date=page.date tooltip=true lang=lang %}</span>
      {% if page.last_modified_at and page.last_modified_at != page.date %}<span>{{ site.data.locales[lang].post.updated }} {% include datetime.html date=page.last_modified_at tooltip=true lang=lang %}</span>{% endif %}
      <div class="d-flex justify-content-between">
        <span>{% if page.author %}{% assign authors = page.author %}{% elsif page.authors %}{% assign authors = page.authors %}{% endif %}{{site.data.locales[lang].post.written_by }}<em>{% if authors %}{% for author in authors %}{% if site.data.authors[author].url -%}<a href="{{ site.data.authors[author].url }}">{{ site.data.authors[author].name }}</a>{%- else -%}{{ site.data.authors[author].name }}{%- endif %}{% unless forloop.last %}{{ '</em>,<em>' }}{% endunless %}{% endfor %}{% else %}<a href="{{ site.social.links[0] }}">{{ site.social.name }}</a>{% endif %}</em></span>
        <div>{% if site.pageviews.provider and site.analytics[site.pageviews.provider].id %}<span><em id="pageviews"><i class="fas fa-spinner fa-spin small"></i></em>{{ site.data.locales[lang].post.pageview_measure }}</span>{% endif %}{% include read-time.html content=content prompt=true lang=lang %}</div>
      </div>
    </div>
  </header>
  
  {% if page.encrypt %}
  <!-- [Encrypted Post] -->
  {% if enable_toc %}{% include toc.html %}{% endif %}
  <div class="content">
    <div id="decryption-wrapper" class="text-center p-4 border rounded">
      <form id="decrypt-form" onsubmit="return false;">
        <i class="fa-solid fa-lock fa-2x mb-3"></i>
        <p class="mb-3">이 포스트는 암호화되어 있습니다. 내용을 보려면 비밀번호를 입력하세요.</p>
        <div class="input-group mb-3 mx-auto" style="max-width: 300px;">
          <input type="password" id="password-input" class="form-control" placeholder="비밀번호" aria-label="Password">
          <button id="decrypt-button" class="btn btn-primary" type="submit">확인</button>
        </div>
        <p id="error-message" class="text-danger small" style="display: none;">비밀번호가 올바르지 않습니다.</p>
      </form>
    </div>
    <div id="decrypted-content" style="display: none;"></div>
  </div>

  {%- capture encrypted_string -%}{{ content | strip_html | strip }}{%- endcapture -%}

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      if (document.getElementById('decryption-wrapper')) {
        const decryptForm = document.getElementById('decrypt-form');
        const passwordInput = document.getElementById('password-input');
        
        const encryptedData = {{ encrypted_string | jsonify }};
        
        const decryptAndDisplay = () => {
          const secretKey = passwordInput.value;
          const errorMessage = document.getElementById('error-message');
          if (!secretKey) return;
          try {
            const decryptedBytes = CryptoJS.AES.decrypt(encryptedData, secretKey);
            const decryptedText = decryptedBytes.toString(CryptoJS.enc.Utf8);
            if (decryptedText) {
              const decryptedContent = document.getElementById('decrypted-content');
              decryptedContent.innerHTML = decryptedText;
              document.getElementById('decryption-wrapper').style.display = 'none';
              decryptedContent.style.display = 'block';
              if (typeof window.toc !== 'undefined') {
                window.toc.init();
              }
            } else {
              throw new Error('Decryption resulted in empty content.');
            }
          } catch (e) {
            errorMessage.style.display = 'block';
            passwordInput.focus();
            console.error('Decryption failed:', e);
          }
        };
        decryptForm.addEventListener('submit', decryptAndDisplay);
      }
    });
  </script>

  {% else %}
  <!-- [Normal Post] -->
    {% if enable_toc %}{% include toc.html %}{% endif %}
    <div class="content">{{ content }}</div>
  {% endif %}
  
  <div class="post-tail-wrapper text-muted">
    <!-- ... post-tail-wrapper content ... -->
    {% if page.categories.size > 0 %}<div class="post-meta mb-3"><i class="far fa-folder-open fa-fw me-1"></i>{% for category in page.categories %}<a href="{{ site.baseurl }}/categories/{{ category | slugify | url_encode }}/">{{ category }}</a>{%- unless forloop.last -%},{%- endunless -%}{% endfor %}</div>{% endif %}
    {% if page.tags.size > 0 %}<div class="post-tags"><i class="fa fa-tags fa-fw me-1"></i>{% for tag in page.tags %}<a href="{{ site.baseurl }}/tags/{{ tag | slugify | url_encode }}/" class="post-tag no-text-decoration">{{- tag -}}</a>{% endfor %}</div>{% endif %}
    <div class="post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2">
      <div class="license-wrapper">{% if site.data.locales[lang].copyright.license.template %}{% capture _replacement %}<a href="{{ site.data.locales[lang].copyright.license.link }}">{{ site.data.locales[lang].copyright.license.name }}</a>{% endcapture %}{{ site.data.locales[lang].copyright.license.template | replace: ':LICENSE_NAME', _replacement }}{% endif %}</div>
      {% include post-sharing.html lang=lang %}
    </div>
  </div>
</article>
```

</details>
<br>

그 외에도 암호화된 내용을 복호화했더니 줄내림이 없어지는 문제도 있어서 파악해보았더니 마크다운 암호화 쪽 문제여서 이런 답변을 받아서 해결하기도 했다.

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

네, 이것은 이 암호화 기능의 가장 핵심적인 난관이자, 반드시 해결해야 할 문제입니다. 말씀하신 대로, 현재 구조에서는 줄바꿈(`\n`)이 제대로 처리되지 않습니다.

### 문제의 진짜 원인

현재 데이터 처리 흐름을 다시 짚어보면 원인이 명확해집니다.

1.  **`cli.js` (암호화)**: 포스트의 **순수한 마크다운(Markdown) 텍스트**를 암호화합니다. 여기에는 `## 제목`이나 `* 목록`, 그리고 단순 줄바꿈 문자(`\n`)가 포함됩니다.
2.  **Jekyll (빌드)**: 암호화된 문자열을 마크다운으로 처리하지 못하고, 그냥 하나의 텍스트 덩어리로 인식하여 `<p>` 태그로 한번 감쌉니다.
3.  **브라우저 (복호화)**:
    *   `<p>` 태그를 벗겨내고 순수 암호문을 얻습니다.
    *   복호화를 수행합니다. 결과물(`decryptedText`)은 다시 **순수한 마크다운 텍스트**가 됩니다.
    *   `decryptedContent.innerHTML = decryptedText;`를 실행합니다.

바로 **마지막 3단계가 문제**입니다. 브라우저는 `innerHTML`에 마크다운 문법을 전달해도 그것이 무엇인지 알지 못합니다. 브라우저가 아는 것은 HTML 뿐입니다.

*   `## 제목`은 그냥 글자가 큰 텍스트가 아니라 `<h2>제목</h2>`이 되어야 합니다.
*   줄바꿈 문자 `\n`은 HTML에서 단순한 공백으로 처리될 뿐, `<br>`이나 `<p>` 태그가 없으면 줄이 바뀌지 않습니다.

### 해결책: 암호화 전에 HTML로 변환하기

가장 확실하고 올바른 해결책은 **클라이언트(브라우저)의 부담을 덜어주는 것**입니다. 즉, `cli.js`에서 마크다운을 **HTML로 변환한 뒤에 그 HTML을 암호화**하는 것입니다.

이렇게 하면 브라우저는 복호화 후에 완성된 HTML을 받게 되므로, `innerHTML`에 넣기만 하면 모든 서식(제목, 목록, 줄바꿈 등)이 완벽하게 렌더링됩니다.

이 작업을 위해 Node.js용 Markdown 파서 라이브러리인 **`marked`**를 사용하겠습니다.

---

### 단계별 해결 절차

#### 1단계: `marked` 라이브러리 설치

터미널에서 프로젝트에 `marked`를 설치합니다.

```bash
npm install marked
```

#### 2단계: `cli.js` 수정

`publishDraft` 함수에서, 본문을 암호화하기 직전에 `marked`를 사용하여 HTML로 변환하는 코드를 한 줄 추가합니다.

```javascript
// cli.js 상단에 import 추가
import { marked } from 'marked';

// ...

// publishDraft 함수 내부 수정
async function publishDraft() {
  // ... 함수 앞부분은 동일 ...

  // 3. 암호화 (모든 내용 변경 후 마지막에 수행)
  let [, frontMatterString, body] = contentForPublishing.split(/---(.*?)---/s);
  const isEncrypted = /encrypt:\s*true/.test(frontMatterString);
  
  if (isEncrypted) {
    const keyIdMatch = /key_id:\s*(.*)/.exec(frontMatterString);
    if (keyIdMatch) {
      const keyId = keyIdMatch[1].trim();
      try {
        const passwords = JSON.parse(fs.readFileSync(PASSWORD_PATH, 'utf-8'));
        const secretKey = passwords.keys[keyId];
        if (!secretKey) throw new Error(`'${keyId}' 키를 찾을 수 없습니다.`);
        
        // ★★★★★ 핵심 수정 부분 ★★★★★
        // 마크다운 본문을 HTML로 변환합니다.
        const bodyAsHtml = marked.parse(body.trim());
        
        // 변환된 HTML을 암호화합니다.
        body = CryptoJS.AES.encrypt(bodyAsHtml, secretKey).toString();
        // ★★★★★★★★★★★★★★★★★★

        console.log('🔒 포스트 본문을 성공적으로 암호화했습니다.');
      } catch (error) {
        console.error(`❌ 암호화 중 오류 발생: ${error.message}`);
        return;
      }
    }
  }

  const finalContent = `---${frontMatterString}---\n${body}`;

  // ... 이하 파일 시스템 및 Git 작업은 동일 ...
}
```

#### 3단계: `_layouts/post.html` 확인 (수정 불필요)

`_layouts/post.html`의 JavaScript 코드는 이미 완벽하게 준비되어 있습니다. 복호화된 결과물(`decryptedText`)이 이제 HTML이므로, `decryptedContent.innerHTML = decryptedText;`는 의도한 대로 정확하게 작동할 것입니다.

### 새로운 워크플로우

1.  **`publish` 실행**: `cli.js`가 마크다운 본문을 읽습니다.
2.  이미지 경로 등을 수정한 후, `marked.parse()`를 호출하여 마크다운 본문을 **완전한 HTML 문자열로 변환**합니다. (이때 `\n\n`는 `<p>` 태그로, `##`는 `<h2>` 태그로 바뀝니다.)
3.  이 **HTML 문자열**을 암호화합니다.
4.  Jekyll은 이 암호화된 문자열을 빌드합니다.
5.  **브라우저**:
    *   사용자가 비밀번호를 입력합니다.
    *   암호문을 복호화하면 **HTML 문자열**이 나옵니다.
    *   이 HTML 문자열을 `innerHTML`에 할당하면, 모든 서식이 완벽하게 적용된 채로 화면에 표시됩니다.

이 방법으로 줄바꿈뿐만 아니라 마크다운으로 작성된 모든 서식이 올바르게 표시되는 문제를 근본적으로 해결할 수 있습니다.

</details>
<br>

이렇게 해서 오늘 만들고자 했던 건 모두 완성.

이제 오늘 새로 배운 것들을 정리해보자...
- post.html을 수정해서 블로그 전체 포스트의 레이아웃을 수정하는 방법.
- CryptoJS를 사용한 AES 암호화 및 복호화 방법.
- Node.js용 Markdown 파서 marked 사용 방법.
