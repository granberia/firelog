---
title: 제미니 vs GPT 유틸리티 코딩
date: 2025-10-01 18:00:00 +0800
categories: [개발]
tags: [개발, 블로그]
---

블로그에 쓸 글 작성용 유틸리티 개발을 LLM에게 맡겨보았다.

### 프롬프트

자바스크립트로 된 CLI를 만들어보자. 아래의 기능들이 필요해.
- 사용자는 명령어를 실행하면 draft와 publish 중 하나를 선택
- draft를 선택하면 사용자로부터 글 제목을 입력받음
- 그 뒤 config.json 파일에 존재하는 목록으로부터 categories, tags를 선택할 수 있게 함. 복수 선택이 가능하므로 사용자가 선택 완료를 따로 선택해야 다음 단계로 넘어감.
- draft 폴더를 생성하거나 이미 존재하는 draft 폴더에 파일을 생성함. 파일명은 위 규칙을 따라 오늘의 날짜와 사용자가 입력한 글 제목을 양식에 맞게 조합함.
- title에는 사용자가 입력한 글 제목을 넣음.
- date에는 지금 시간을 넣음.
- categories에는 사용자가 선택한 값들을 넣음.
- tags에는 사용자가 선택한 값들을 넣음.
- 사용자가 글을 다 쓰고 명렁어를 실행해서 publish를 선택하면 draft 폴더에 있는 파일을 _posts로 옮기고 commit함, 커밋 메시지는 chore: (새 파일명.md) 가 됨. 그 뒤 자동으로 push함.

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

알겠습니다. 사용자의 요구사항을 완벽하게 충족하는 자바스크립트 기반의 CLI(Command Line Interface) 도구를 만들어보겠습니다. 이 도구는 `inquirer` 라이브러리를 사용하여 상호작용적인 사용자 경험을 제공하고, `git` 명령어 자동화를 통해 포스팅 과정을 획기적으로 개선할 것입니다.

먼저, 프로젝트의 전체적인 구조와 설정 방법, 그리고 완성된 코드 순서로 설명하겠습니다.

---

### **프로젝트 설정 (Project Setup)**

1.  **Node.js 설치:** 컴퓨터에 [Node.js](https://nodejs.org/)가 설치되어 있어야 합니다.
2.  **프로젝트 폴더 생성:** 블로그 프로젝트의 최상위 폴더에서 터미널을 엽니다.
3.  **`package.json` 생성:**
    ```bash
    npm init -y
    ```
4.  **필요한 라이브러리 설치:**
    *   `inquirer`: 사용자 입력을 받기 위한 라이브러리
    *   `slugify`: 글 제목을 URL에 적합한 형태(slug)로 변환하는 라이브러리
    ```bash
    npm install inquirer slugify
    ```
5.  **파일 생성:** 프로젝트 루트에 다음 세 개의 파일을 생성합니다.
    *   `cli.js`: CLI 도구의 핵심 로직이 담길 파일
    *   `config.json`: 카테고리 및 태그 목록을 관리하는 설정 파일
    *   `.gitignore`: `node_modules` 폴더를 git 추적에서 제외하기 위한 파일

---

### **파일 내용 (File Contents)**

#### **1. `.gitignore`**
git이 불필요한 파일을 추적하지 않도록 설정합니다.
```
node_modules
```

#### **2. `config.json`**
블로그에서 사용할 카테고리와 태그 목록을 미리 정의해둡니다. 이 파일을 수정하여 언제든지 선택지를 변경할 수 있습니다.

```json
{
  "categories": [
    "일상생활",
    "기술",
    "개발",
    "TRPG",
    "리뷰"
  ],
  "tags": [
    "일상",
    "Jekyll",
    "JavaScript",
    "NodeJS",
    "CLI",
    "자동화"
  ]
}
```

#### **3. `cli.js` (핵심 CLI 스크립트)**
아래 코드를 복사하여 `cli.js` 파일에 붙여넣으세요. 코드 각 부분에 상세한 주석을 달아 이해하기 쉽게 만들었습니다.

```javascript
#!/usr/bin/env node

// 필요한 라이브러리 및 모듈 가져오기
import inquirer from 'inquirer';
import slugify from 'slugify';
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

// package.json에서 type: "module"을 사용하기 위해 import 구문 사용

// --- 경로 및 설정 상수 정의 ---
const DRAFTS_DIR = '_drafts'; // Jekyll 표준 초안 폴더
const POSTS_DIR = '_posts';
const CONFIG_PATH = 'config.json';

// --- 헬퍼 함수 ---

/**
 * YYYY-MM-DD 형식의 날짜 문자열을 반환하는 함수
 * @returns {string}
 */
function getFormattedDate() {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Jekyll 머리말(front matter)에 사용될 날짜 및 시간 문자열을 반환하는 함수
 * @returns {string}
 */
function getFullDateTime() {
    const date = new Date();
    const offset = -date.getTimezoneOffset();
    const offsetHours = String(Math.floor(Math.abs(offset) / 60)).padStart(2, '0');
    const offsetMinutes = String(Math.abs(offset) % 60).padStart(2, '0');
    const sign = offset >= 0 ? '+' : '-';
    
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${sign}${offsetHours}${offsetMinutes}`;
}

// --- 핵심 기능 함수 ---

/**
 * 새로운 초안(draft) 포스트를 생성하는 함수
 */
async function createDraft() {
  // 1. 설정 파일 읽기
  let config;
  try {
    config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (error) {
    console.error(`❌ 설정 파일(${CONFIG_PATH})을 읽을 수 없습니다. 파일이 존재하고 JSON 형식이 올바른지 확인하세요.`);
    return;
  }

  // 2. 사용자로부터 정보 입력받기 (제목, 카테고리, 태그)
  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'title',
      message: '📝 포스트 제목을 입력하세요:',
      validate: (input) => input ? true : '제목은 비워둘 수 없습니다.',
    },
    {
      type: 'checkbox',
      name: 'categories',
      message: '📂 카테고리를 선택하세요 (스페이스바로 선택, 엔터로 확정):',
      choices: config.categories,
      validate: (input) => input.length > 0 ? true : '하나 이상의 카테고리를 선택해야 합니다.',
    },
    {
      type: 'checkbox',
      name: 'tags',
      message: '🏷️ 태그를 선택하세요 (스페이스바로 선택, 엔터로 확정):',
      choices: config.tags,
    }
  ]);

  // 3. 파일명 및 내용 생성
  const { title, categories, tags } = answers;
  const slug = slugify(title, { lower: true, strict: true });
  const date = getFormattedDate();
  const fileName = `${date}-${slug}.md`;
  const filePath = path.join(DRAFTS_DIR, fileName);

  const fileContent = `---
title: "${title}"
date: ${getFullDateTime()}
categories: [${categories.join(', ')}]
tags: [${tags.join(', ')}]
---

여기에 마크다운 내용을 작성하세요.
`;

  // 4. 파일 생성
  if (!fs.existsSync(DRAFTS_DIR)) {
    fs.mkdirSync(DRAFTS_DIR);
    console.log(`📁 '${DRAFTS_DIR}' 폴더를 생성했습니다.`);
  }

  fs.writeFileSync(filePath, fileContent);
  console.log(`✅ 초안 파일이 성공적으로 생성되었습니다: ${filePath}`);
}

/**
 * 초안(draft) 파일을 _posts 폴더로 옮겨 발행(publish)하는 함수
 */
async function publishDraft() {
  // 1. 초안 폴더 확인 및 파일 목록 가져오기
  if (!fs.existsSync(DRAFTS_DIR)) {
    console.log('🤷 초안 폴더가 없습니다. 먼저 draft 명령어로 글을 생성하세요.');
    return;
  }

  const draftFiles = fs.readdirSync(DRAFTS_DIR).filter(file => file.endsWith('.md'));

  if (draftFiles.length === 0) {
    console.log('🤷 발행할 초안 파일이 없습니다.');
    return;
  }

  // 2. 사용자에게 발행할 파일 선택받기
  const { fileToPublish } = await inquirer.prompt([
    {
      type: 'list',
      name: 'fileToPublish',
      message: '🚀 발행할 초안 파일을 선택하세요:',
      choices: draftFiles,
    },
  ]);

  // 3. 파일 이동
  const sourcePath = path.join(DRAFTS_DIR, fileToPublish);
  const destPath = path.join(POSTS_DIR, fileToPublish);

  if (!fs.existsSync(POSTS_DIR)) {
    fs.mkdirSync(POSTS_DIR);
  }

  fs.renameSync(sourcePath, destPath);
  console.log(`✅ 파일 이동 완료: ${sourcePath} -> ${destPath}`);

  // 4. Git 명령어 실행 (add, commit, push)
  try {
    console.log('📦 Git에 변경사항을 커밋하고 푸시합니다...');
    execSync(`git add "${destPath}"`);
    console.log(`  -> git add ${destPath}`);
    
    const commitMessage = `chore: publish ${fileToPublish}`;
    execSync(`git commit -m "${commitMessage}"`);
    console.log(`  -> git commit -m "${commitMessage}"`);

    execSync('git push');
    console.log('  -> git push');
    
    console.log('🎉 포스트 발행이 성공적으로 완료되었습니다!');
  } catch (error) {
    console.error('❌ Git 작업 중 오류가 발생했습니다. Git이 설치되어 있고, 저장소 설정이 올바른지 확인하세요.');
    console.error(error.message);
  }
}


/**
 * 메인 함수
 */
async function main() {
  const { action } = await inquirer.prompt([
    {
      type: 'list',
      name: 'action',
      message: '👋 안녕하세요! 무엇을 도와드릴까요?',
      choices: [
        { name: '새로운 초안(draft) 작성하기', value: 'draft' },
        { name: '초안을 포스트로 발행(publish)하기', value: 'publish' },
        { name: '종료', value: 'exit' },
      ],
    },
  ]);

  switch (action) {
    case 'draft':
      await createDraft();
      break;
    case 'publish':
      await publishDraft();
      break;
    case 'exit':
      console.log('👋 다음에 또 만나요!');
      break;
  }
}

// 스크립트 실행
main();
```

---

### **사용 방법 (How to Use)**

1.  **`package.json` 수정:** `cli.js`가 ES 모듈(`import`)을 사용하므로, `package.json` 파일에 다음 한 줄을 추가해야 합니다.
    ```json
    {
      "name": "my-blog",
      "version": "1.0.0",
      "description": "",
      "main": "cli.js",
      "type": "module",  // <-- 이 줄을 추가하세요!
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "keywords": [],
      "author": "",
      "license": "ISC",
      "dependencies": {
        "inquirer": "^9.2.11",
        "slugify": "^1.6.6"
      }
    }
    ```

2.  **CLI 실행:** 터미널에서 다음 명령어를 입력하여 스크립트를 실행합니다.
    ```bash
    node cli.js
    ```

#### **실행 예시**

**1. 초안(draft) 작성**

```
$ node cli.js
? 👋 안녕하세요! 무엇을 도와드릴까요? › 새로운 초안(draft) 작성하기
? 📝 포스트 제목을 입력하세요: 나만의 블로그 자동화 CLI 만들기
? 📂 카테고리를 선택하세요 (스페이스바로 선택, 엔터로 확정): › 
 ◯ 일상생활
 ◉ 기술
 ◉ 개발
 ◯ TRPG
 ◯ 리뷰
? 🏷️ 태그를 선택하세요 (스페이스바로 선택, 엔터로 확정): › 
 ◯ 일상
 ◯ Jekyll
 ◉ JavaScript
 ◉ NodeJS
 ◉ CLI
 ◉ 자동화

📁 '_drafts' 폴더를 생성했습니다.
✅ 초안 파일이 성공적으로 생성되었습니다: _drafts/2025-09-30-namanui-beulrogeu-jadonghwa-cli-mandeulgi.md
```

**2. 초안 발행(publish)**
```
$ node cli.js
? 👋 안녕하세요! 무엇을 도와드릴까요? › 초안을 포스트로 발행(publish)하기
? 🚀 발행할 초안 파일을 선택하세요: › 2025-09-30-namanui-beulrogeu-jadonghwa-cli-mandeulgi.md

✅ 파일 이동 완료: _drafts/2025-09-30...md -> _posts/2025-09-30...md
📦 Git에 변경사항을 커밋하고 푸시합니다...
  -> git add _posts/2025-09-30-namanui-beulrogeu-jadonghwa-cli-mandeulgi.md
  -> git commit -m "chore: publish 2025-09-30-namanui-beulrogeu-jadonghwa-cli-mandeulgi.md"
  -> git push
🎉 포스트 발행이 성공적으로 완료되었습니다!
```

이 CLI 도구를 통해 단순 반복 작업을 자동화하여 글쓰기 자체에 더욱 집중할 수 있게 될 것입니다.

</details>

### GPT-5의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

좋아! 👌 요구사항대로라면 Node.js 기반의 CLI 툴을 만들 수 있어.
아래는 **자바스크립트(Node.js) + inquirer + fs + simple-git**을 활용한 예시 코드야.

---

# 📂 프로젝트 구조 예시

```
blog-cli/
├─ config.json
├─ cli.js
├─ package.json
├─ draft/         # 초안 폴더
└─ _posts/        # 배포 폴더
```

### config.json (예시)

```json
{
  "categories": ["일상생활", "개발", "여행", "책리뷰"],
  "tags": ["블로그", "일상", "코딩", "책"]
}
```

---

# 📜 cli.js

```js
#!/usr/bin/env node

import fs from "fs";
import path from "path";
import inquirer from "inquirer";
import { fileURLToPath } from "url";
import simpleGit from "simple-git";

// 현재 디렉토리 계산
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const draftDir = path.join(__dirname, "draft");
const postsDir = path.join(__dirname, "_posts");
const configPath = path.join(__dirname, "config.json");
const git = simpleGit();

function slugify(title) {
  return title
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-zA-Z0-9가-힣\s-]/g, "")
    .trim()
    .replace(/\s+/g, "-")
    .toLowerCase();
}

async function createDraft() {
  // 글 제목 입력
  const { title } = await inquirer.prompt([
    {
      type: "input",
      name: "title",
      message: "글 제목을 입력하세요:",
      validate: (input) => input.length > 0 || "제목은 비워둘 수 없습니다."
    }
  ]);

  // config.json 읽기
  const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));

  // 카테고리 선택
  const { categories } = await inquirer.prompt([
    {
      type: "checkbox",
      name: "categories",
      message: "카테고리를 선택하세요 (스페이스로 선택, 엔터로 확정):",
      choices: config.categories,
    }
  ]);

  // 태그 선택
  const { tags } = await inquirer.prompt([
    {
      type: "checkbox",
      name: "tags",
      message: "태그를 선택하세요 (스페이스로 선택, 엔터로 확정):",
      choices: config.tags,
    }
  ]);

  // 파일 생성
  if (!fs.existsSync(draftDir)) fs.mkdirSync(draftDir);

  const date = new Date();
  const dateStr = date.toISOString().split("T")[0]; // YYYY-MM-DD
  const slug = slugify(title);
  const filename = `${dateStr}-${slug}.md`;
  const filepath = path.join(draftDir, filename);

  const frontMatter = `---
title: ${title}
date: ${date.toISOString()}
categories: [${categories.join(", ")}]
tags: [${tags.join(", ")}]
draft: true
---
`;

  fs.writeFileSync(filepath, frontMatter);
  console.log(`✅ Draft created: ${filepath}`);
}

async function publishDraft() {
  if (!fs.existsSync(draftDir)) {
    console.log("❌ draft 폴더가 존재하지 않습니다.");
    return;
  }

  const files = fs.readdirSync(draftDir).filter(f => f.endsWith(".md"));
  if (files.length === 0) {
    console.log("❌ 옮길 draft 파일이 없습니다.");
    return;
  }

  // 파일 선택
  const { selectedFile } = await inquirer.prompt([
    {
      type: "list",
      name: "selectedFile",
      message: "어떤 draft를 publish 하시겠습니까?",
      choices: files,
    }
  ]);

  const src = path.join(draftDir, selectedFile);
  const dest = path.join(postsDir, selectedFile);

  if (!fs.existsSync(postsDir)) fs.mkdirSync(postsDir);

  // 이동
  fs.renameSync(src, dest);

  // git commit & push
  await git.add(dest);
  await git.commit(`chore: (${selectedFile})`);
  await git.push();

  console.log(`🚀 Published: ${selectedFile}`);
}

async function main() {
  const { action } = await inquirer.prompt([
    {
      type: "list",
      name: "action",
      message: "무엇을 하시겠습니까?",
      choices: ["draft", "publish"]
    }
  ]);

  if (action === "draft") {
    await createDraft();
  } else if (action === "publish") {
    await publishDraft();
  }
}

main();
```

---

# 🚀 사용법

1. 설치

```bash
npm init -y
npm install inquirer simple-git
chmod +x cli.js
```

2. 실행

```bash
./cli.js
```

* **draft 선택 시** → 제목 입력 → categories/tags 선택 → `draft/YYYY-MM-DD-slug.md` 생성
* **publish 선택 시** → draft 목록에서 파일 선택 → `_posts`로 이동 → `git commit` & `push` 자동 실행

---

👉 여기서 개선할 수 있는 점:

* 다국어 제목을 슬러그화하는 규칙을 더 정교하게 (현재는 단순 변환).
* commit/push 전에 `git status` 확인 → 오류 메시지 처리.
* draft → publish 과정에서 front-matter의 `draft: true`를 자동으로 `false`로 바꿔주도록 확장 가능.

---

원해? 내가 `publish` 과정에서 **front-matter 안의 draft 값을 false로 바꿔주는 기능**까지 추가해줄까?

</details>
<br>

이제 두 LLM이 전달해준 결과를 그대로 사용해봤는데, 제미니 2.5 프로는 일단 파일명에서 문제를 일으킨다.

한글로 포스트 제목을 입력했더니 2025-10-01-.md 처럼 파일명이 끊겼다.

아마 slugify에서 한글을 올바르게 처리하지 못하는 것 같다.

GPT-5도 마찬가지로 똑같은 문제를 파일명에서 일으킨다. 그리고 date의 작성 양식이 틀렸다.

이전 프롬프트에서 Jekyll에 Chirpy 테마를 적용한 블로그라고 명시를 하며 글 예시를 넣었는데, 제미니가 좀 더 똘똘하게 작동한 듯.

까짓거, 한글이 파일명에 안 들어가는 문제도 고쳐보라고 해보자.

### 제미니 2.5 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

알겠습니다. 정확한 지적입니다.

해당 문제는 `slugify` 라이브러리의 기본 설정 때문에 발생합니다. `strict: true` 옵션은 URL에 사용하기 안전한 영문, 숫자, 하이픈(-) 등 일부 문자만 남기고 나머지 문자(한글 포함)를 모두 제거해버립니다.

**한글을 파일명에 그대로 사용하도록 이 문제를 해결하겠습니다.**

### **문제 원인 및 해결 방안**

*   **원인:** `slugify(title, { lower: true, strict: true })` 설정이 한글을 제거함.
*   **해결:** `slugify`의 옵션을 변경하여 한글을 인식하고, 공백만 하이픈으로 바꾸도록 설정합니다. `strict` 옵션을 `false`로 바꾸고, `locale` 옵션으로 한국어를 명시해주는 것이 가장 확실한 방법입니다.

### **수정할 코드**

`cli.js` 파일의 `createDraft` 함수 내부에서 `slug`를 생성하는 부분을 다음과 같이 수정해주세요.

**1. `cli.js` 파일 열기**

**2. `createDraft` 함수 찾기**

**3. 기존 코드 (AS-IS)**
```javascript
// ... createDraft 함수 내부 ...
  const slug = slugify(title, { lower: true, strict: true });
// ...
```

**4. 수정된 코드 (TO-BE)**
아래 코드로 교체해주세요.

```javascript
// ... createDraft 함수 내부 ...
  const slug = slugify(title, {
    lower: false,     // 한글은 소문자 변환이 의미 없으므로 false로 설정
    strict: false,    // 한글 등 특수문자 제거 방지
    locale: 'ko',     // 한국어 로케일 설정
    trim: true        // 앞뒤 공백 제거
  });
// ...
```
*   `lower: false`: 한글은 대소문자 구분이 없으므로 `false`로 변경하여 불필요한 처리를 막습니다.
*   `strict: false`: **가장 중요한 옵션입니다.** `true`일 경우 한글이 모두 제거되므로 `false`로 변경하여 유지시킵니다.
*   `locale: 'ko'`: 한국어 환경임을 명시하여 `slugify`가 문자열을 더 잘 처리하도록 돕습니다.

---

### **전체 수정된 `cli.js` 파일**

사용자의 편의를 위해 수정 사항이 적용된 전체 `cli.js` 코드를 다시 제공합니다. 이 코드를 그대로 복사하여 붙여넣으시면 됩니다.

```javascript
#!/usr/bin/env node

import inquirer from 'inquirer';
import slugify from 'slugify';
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

const DRAFTS_DIR = '_drafts';
const POSTS_DIR = '_posts';
const CONFIG_PATH = 'config.json';

function getFormattedDate() {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function getFullDateTime() {
    const date = new Date();
    const offset = -date.getTimezoneOffset();
    const offsetHours = String(Math.floor(Math.abs(offset) / 60)).padStart(2, '0');
    const offsetMinutes = String(Math.abs(offset) % 60).padStart(2, '0');
    const sign = offset >= 0 ? '+' : '-';
    
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${sign}${offsetHours}${offsetMinutes}`;
}

async function createDraft() {
  let config;
  try {
    config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (error) {
    console.error(`❌ 설정 파일(${CONFIG_PATH})을 읽을 수 없습니다. 파일이 존재하고 JSON 형식이 올바른지 확인하세요.`);
    return;
  }

  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'title',
      message: '📝 포스트 제목을 입력하세요:',
      validate: (input) => input ? true : '제목은 비워둘 수 없습니다.',
    },
    {
      type: 'checkbox',
      name: 'categories',
      message: '📂 카테고리를 선택하세요 (스페이스바로 선택, 엔터로 확정):',
      choices: config.categories,
      validate: (input) => input.length > 0 ? true : '하나 이상의 카테고리를 선택해야 합니다.',
    },
    {
      type: 'checkbox',
      name: 'tags',
      message: '🏷️ 태그를 선택하세요 (스페이스바로 선택, 엔터로 확정):',
      choices: config.tags,
    }
  ]);

  const { title, categories, tags } = answers;
  
  // ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
  // 여기가 수정된 부분입니다.
  const slug = slugify(title, {
    lower: false,     // 한글은 소문자 변환이 의미 없으므로 false로 설정
    strict: false,    // 한글 등 특수문자 제거 방지
    locale: 'ko',     // 한국어 로케일 설정
    trim: true        // 앞뒤 공백 제거
  });
  // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

  const date = getFormattedDate();
  const fileName = `${date}-${slug}.md`;
  const filePath = path.join(DRAFTS_DIR, fileName);

  const fileContent = `---
title: "${title}"
date: ${getFullDateTime()}
categories: [${categories.join(', ')}]
tags: [${tags.join(', ')}]
---

여기에 마크다운 내용을 작성하세요.
`;

  if (!fs.existsSync(DRAFTS_DIR)) {
    fs.mkdirSync(DRAFTS_DIR);
    console.log(`📁 '${DRAFTS_DIR}' 폴더를 생성했습니다.`);
  }

  fs.writeFileSync(filePath, fileContent);
  console.log(`✅ 초안 파일이 성공적으로 생성되었습니다: ${filePath}`);
}

async function publishDraft() {
  if (!fs.existsSync(DRAFTS_DIR)) {
    console.log('🤷 초안 폴더가 없습니다. 먼저 draft 명령어로 글을 생성하세요.');
    return;
  }

  const draftFiles = fs.readdirSync(DRAFTS_DIR).filter(file => file.endsWith('.md'));

  if (draftFiles.length === 0) {
    console.log('🤷 발행할 초안 파일이 없습니다.');
    return;
  }

  const { fileToPublish } = await inquirer.prompt([
    {
      type: 'list',
      name: 'fileToPublish',
      message: '🚀 발행할 초안 파일을 선택하세요:',
      choices: draftFiles,
    },
  ]);

  const sourcePath = path.join(DRAFTS_DIR, fileToPublish);
  const destPath = path.join(POSTS_DIR, fileToPublish);

  if (!fs.existsSync(POSTS_DIR)) {
    fs.mkdirSync(POSTS_DIR);
  }

  fs.renameSync(sourcePath, destPath);
  console.log(`✅ 파일 이동 완료: ${sourcePath} -> ${destPath}`);

  try {
    console.log('📦 Git에 변경사항을 커밋하고 푸시합니다...');
    execSync(`git add "${destPath}"`);
    console.log(`  -> git add ${destPath}`);
    
    const commitMessage = `chore: publish ${fileToPublish}`;
    execSync(`git commit -m "${commitMessage}"`);
    console.log(`  -> git commit -m "${commitMessage}"`);

    execSync('git push');
    console.log('  -> git push');
    
    console.log('🎉 포스트 발행이 성공적으로 완료되었습니다!');
  } catch (error) {
    console.error('❌ Git 작업 중 오류가 발생했습니다. Git이 설치되어 있고, 저장소 설정이 올바른지 확인하세요.');
    console.error(error.message);
  }
}

async function main() {
  const { action } = await inquirer.prompt([
    {
      type: 'list',
      name: 'action',
      message: '👋 안녕하세요! 무엇을 도와드릴까요?',
      choices: [
        { name: '새로운 초안(draft) 작성하기', value: 'draft' },
        { name: '초안을 포스트로 발행(publish)하기', value: 'publish' },
        { name: '종료', value: 'exit' },
      ],
    },
  ]);

  switch (action) {
    case 'draft':
      await createDraft();
      break;
    case 'publish':
      await publishDraft();
      break;
    case 'exit':
      console.log('👋 다음에 또 만나요!');
      break;
  }
}

main();

```

이제 `node cli.js`를 실행하고 한글 제목을 입력하면 파일명이 정상적으로 생성될 것입니다.

**예시:**
*   **입력 제목:** `새로운 한글 포스트`
*   **생성될 파일명:** `2025-10-01-새로운-한글-포스트.md`

</details>


### GPT-5의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

아하 👍 그건 내가 만든 `slugify` 함수가 **영문/숫자만 남기고 한글은 다 지워버리기 때문**이야. 지금 정규식이 `replace(/[^a-zA-Z0-9가-힣\s-]/g, "")`인데, 뒤에서 `iconv` 비슷한 처리가 들어가면서 한글이 사라진 거지.

👉 해결책은 크게 두 가지가 있어:

---

## 1. 한글을 그대로 허용하는 slug (추천)

URL에 한글이 들어가도 요즘 브라우저는 퍼센트 인코딩으로 잘 처리하니까, 파일명에도 한글을 두고 싶다면 이렇게 수정하면 돼.

```js
function slugify(title) {
  return title
    .trim()
    .replace(/\s+/g, "-")        // 공백 → -
    .replace(/-+/g, "-")         // 중복 - 제거
    .toLowerCase();
}
```

이러면 예를 들어:

```
"나만의 블로그 탄생" → "나만의-블로그-탄생"
```

파일명은 `2025-10-01-나만의-블로그-탄생.md` 식으로 나와.

---

## 2. 한글은 로마자로 변환해서 slug (SEO 목적)

검색 엔진이나 URL 안정성을 위해 slug는 영문만 쓰고 싶으면, **transliteration 라이브러리**를 쓰는 게 좋아.
예시: [`slugify`](https://www.npmjs.com/package/slugify) 패키지.

```bash
npm install slugify
```

```js
import slugifyLib from "slugify";

function slugify(title) {
  return slugifyLib(title, {
    lower: true,
    strict: true // 특수문자 제거
  });
}
```

그러면

```
"나만의 블로그 탄생" → "namanyi-beullogeu-tansaeng"
```

이런 식으로 영문 slug가 생성돼.

---

👉 질문: 네 블로그 파일명/URL에서 **한글 그대로 쓰는 게 좋아?** 아니면 **영문 slug로 변환하는 게 좋아?**
둘 다 코드로 맞춰서 완성해줄 수 있어.

</details>
<br>

두 코드를 모두 테스트해보았을 때 제미니 2.5 프로는 여전히 한글이 포함된 파일명을 생성하지 못했다.

LLM이 slugify 모듈의 옵션 값을 올바르게 설정하지 못한 것 같다. 자체 slugify를 구현한 GPT의 승리.

publish 기능까지 테스트해보았을 때 둘 다 잘 작동했지만 GPT가 만든 코드는 중간 과정에 로그를 안 보여줘서 약간 갑갑했다.

누구 하나 완벽하게 작동한 LLM은 없지만 잘 작동하는 코드끼리 내가 합쳐보자.

### 결과 정리

- 파일명 생성은 GPT가 정상적으로 작동, 제미니의 코드는 작동하지 않음.
- title은 GPT가 정상적으로 생성, 제미니가 생성한 타이틀은 양 옆에 쌍따옴표가 포함됨.
- date는 제미니가 필요한 규격에 맞게 생성, GPT가 생성한 date는 2025-10-01T11:59:23.725Z 로 묘하게 규격이 다름.
- tags는 둘 다 정상적으로 생성됨.
- GPT는 불필요하게 draft: true를 넣었는데, 굳이? 싶음.
- publish 과정은 GPT가 추천한 라이브러리가 정상적으로 작동함.
- publish 사이사이 콘솔 로그는 제미니가 더 자세하게 남겨줌.

### AI 발전의 혜택을 누리며...

이렇게 저렇게 합쳐서 코드를 완성했다.

계획표를 _tabs 폴더에서 관리하고 있으니 _tabs 폴더만 따로 배포하는 기능도 겸사겸사 넣었다.

<details markdown="1">
<summary>완성된 코드 접기/펴기</summary>

```js
#!/usr/bin/env node

import inquirer from 'inquirer';
import fs from 'fs';
import path from 'path';
import simpleGit from 'simple-git';

const DRAFTS_DIR = '_drafts';
const POSTS_DIR = '_posts';
const TABS_DIR = '_tabs';
const CONFIG_PATH = 'config.json';
const git = simpleGit();

async function gitConfig() {
  await git.addConfig('user.name', 'granberia');
  await git.addConfig('user.email', 'reptilesax@gmail.com');
}

function slugify(title) {
  return title
    .trim()
    .replace(/\s+/g, '-') // 공백 → -
    .replace(/-+/g, '-'); // 중복 - 제거
}

function getFormattedDate() {
  const date = new Date();
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function getFullDateTime() {
  const date = new Date();
  const offset = -date.getTimezoneOffset();
  const offsetHours = String(Math.floor(Math.abs(offset) / 60)).padStart(
    2,
    '0'
  );
  const offsetMinutes = String(Math.abs(offset) % 60).padStart(2, '0');
  const sign = offset >= 0 ? '+' : '-';

  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');

  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${sign}${offsetHours}${offsetMinutes}`;
}

async function createDraft() {
  let config;
  try {
    config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf-8'));
  } catch (error) {
    console.error(
      `❌ 설정 파일(${CONFIG_PATH})을 읽을 수 없습니다. 파일이 존재하고 JSON 형식이 올바른지 확인하세요.`
    );
    return;
  }

  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'title',
      message: '📝 포스트 제목을 입력하세요:',
      validate: (input) => (input ? true : '제목은 비워둘 수 없습니다.')
    },
    {
      type: 'checkbox',
      name: 'categories',
      message: '📂 카테고리를 선택하세요 (스페이스바로 선택, 엔터로 확정):',
      choices: config.categories,
      validate: (input) =>
        input.length > 0 ? true : '하나 이상의 카테고리를 선택해야 합니다.'
    },
    {
      type: 'checkbox',
      name: 'tags',
      message: '🏷️ 태그를 선택하세요 (스페이스바로 선택, 엔터로 확정):',
      choices: config.tags
    }
  ]);

  const { title, categories, tags } = answers;

  const date = getFormattedDate();
  const slug = slugify(title);
  const fileName = `${date}-${slug}.md`;
  const filePath = path.join(DRAFTS_DIR, fileName);

  const fileContent = `---
title: ${title}
date: ${getFullDateTime()}
categories: [${categories.join(', ')}]
tags: [${tags.join(', ')}]
---

`;

  if (!fs.existsSync(DRAFTS_DIR)) {
    fs.mkdirSync(DRAFTS_DIR);
    console.log(`📁 '${DRAFTS_DIR}' 폴더를 생성했습니다.`);
  }

  fs.writeFileSync(filePath, fileContent);
  console.log(`✅ 초안 파일이 성공적으로 생성되었습니다: ${filePath}`);
}

async function publishDraft() {
  if (!fs.existsSync(DRAFTS_DIR)) {
    console.log(
      '🤷 초안 폴더가 없습니다. 먼저 draft 명령어로 글을 생성하세요.'
    );
    return;
  }

  const draftFiles = fs
    .readdirSync(DRAFTS_DIR)
    .filter((file) => file.endsWith('.md'));

  if (draftFiles.length === 0) {
    console.log('🤷 발행할 초안 파일이 없습니다.');
    return;
  }

  const { fileToPublish } = await inquirer.prompt([
    {
      type: 'list',
      name: 'fileToPublish',
      message: '🚀 발행할 초안 파일을 선택하세요:',
      choices: draftFiles
    }
  ]);

  const sourcePath = path.join(DRAFTS_DIR, fileToPublish);
  const destPath = path.join(POSTS_DIR, fileToPublish);

  if (!fs.existsSync(POSTS_DIR)) {
    fs.mkdirSync(POSTS_DIR);
  }

  fs.renameSync(sourcePath, destPath);
  console.log(`✅ 파일 이동 완료: ${sourcePath} -> ${destPath}`);

  try {
    console.log('📦 Git에 변경사항을 커밋하고 푸시합니다...');
    gitConfig();

    console.log(`  -> git add ${destPath}`);
    await git.add(destPath);

    console.log(`  -> git commit -m "chore: ${fileToPublish}"`);
    await git.commit(`chore: ${fileToPublish}`);

    console.log('  -> git push');
    await git.push();

    console.log('🎉 포스트 발행이 성공적으로 완료되었습니다!');
  } catch (error) {
    console.error(
      '❌ Git 작업 중 오류가 발생했습니다. Git이 설치되어 있고, 저장소 설정이 올바른지 확인하세요.'
    );
    console.error(error.message);
  }
}

async function updateTabs() {
  if (!fs.existsSync(TABS_DIR)) {
    console.log(
      `🤷 '${TABS_DIR}' 폴더가 존재하지 않습니다. 작업을 진행할 수 없습니다.`
    );
    return;
  }

  try {
    console.log(`📦 '${TABS_DIR}' 폴더의 변경사항을 배포합니다...`);
    gitConfig();

    console.log(`  -> git add ${TABS_DIR}`);
    await git.add(TABS_DIR);

    console.log('  -> git commit -m "chore: deploy tabs"');
    await git.commit('chore: deploy tabs');

    console.log('  -> git push');
    await git.push();

    console.log(`🎉 '${TABS_DIR}' 폴더 배포가 성공적으로 완료되었습니다!`);
  } catch (error) {
    if (error.stdout.toString().includes('nothing to commit')) {
      console.log('🤷 커밋할 변경사항이 없습니다. 작업을 종료합니다.');
    } else {
      console.error(
        '❌ Git 작업 중 오류가 발생했습니다. Git 상태를 확인해주세요.'
      );
      console.error(error.message);
    }
  }
}

async function main() {
  const { action } = await inquirer.prompt([
    {
      type: 'list',
      name: 'action',
      message: '👋 안녕하세요! 무엇을 도와드릴까요?',
      choices: [
        { name: '새로운 초안 작성하기', value: 'draft' },
        { name: '초안을 포스트로 발행하기', value: 'publish' },
        { name: '전체 탭을 배포하기', value: 'update' },
        { name: '종료', value: 'exit' }
      ]
    }
  ]);

  switch (action) {
    case 'draft':
      await createDraft();
      break;
    case 'publish':
      await publishDraft();
      break;
    case 'update':
      await updateTabs();
      break;
    case 'exit':
      console.log('👋 다음에 또 만나요!');
      break;
  }
}

main();
```

<details markdown="1">
<br>

테스트해보았을 때 잘 작동하는 것 같다.

이걸 내가 손으로 붙들고 있었으면 시간이 3배 정도 걸렸을까? 이런 번거로운 코딩은 AI한테 맡겨도 되는 게 편리하다.

inquirer랑 simple-git라는 라이브러리들을 소개받은 것도 꽤 도움이 되었다.

이제 좀 글을 쓰기 편해지려나...
