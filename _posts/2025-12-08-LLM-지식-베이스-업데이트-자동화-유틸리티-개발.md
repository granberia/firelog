---
title: LLM 지식 베이스 업데이트 자동화 유틸리티 개발
date: 2025-12-08 02:13:16 +0900
categories: [개발]
tags: [개발, AI 채팅, TRPG]
---


TRPG 세션 로그 추출기를 완성했으니 추출된 로그들을 LLM에 주입해서 지식 베이스로 추출하는 유틸리티를 만들어야 한다.

최신 제미니 모델인 3.0 Pro를 무료로 사용하려면 구글 AI 스튜디오 사이트를 이용해야 하니까 API를 사용한 방식은 일단 고려하지 말자.

먼저 지식 베이스 업데이트 작동 순서를 정리해보면...

- 사용자는 experiment 폴더 내부의 캠페인 폴더 중 하나를 고른다.
- 캠페인 폴더 내부의 log 폴더 안에 있는 파일 중 하나를 고른다.
- 사용자는 이 로그를 무엇이라고 부를지 정한다. LLM에게 2025120201.html이나 14-3.html을 이름 그대로 넘겨주면 몇 번째 에피소드인지 알 수 없으니까.
- Playwright로 구글 AI 스튜디오를 실행한다. 일단은 각 캠페인마다 다른 시스템 프롬프트가 들어간 링크로 보내고, 나중에는 새 채팅으로 시스템 프롬프트를 넣는 형태로 바꿔보자. 안 귀찮으면 영영 안 바꿀 것 같지만...
- AI 스튜디오 내부에 기존 프롬프트가 있다면 전부 삭제하자. 예전에 AI 스튜디오에 이 기능이 있었는데 아쉬운걸. 그냥 현재 시스템 프롬프트를 읽어온 뒤 전체 초기화 버튼을 누를까?
- KB.txt의 내용을 프롬프트로 입력하자.
- 사용자가 선택한 로그의 내용을 입력한 타이틀을 붙여서 프롬프트로 입력하자.
- 로그를 통해 업데이트된 전체 지식 베이스 파일의 목록을 출력하는 프롬프트를 입력하자.
- 돌아온 답변을 배열로 만들어서 모든 파일명을 순회하며 업데이트를 시작하자.
  - 파일명을 프롬프트로 입력해서 내용을 출력하자.
  - 출력된 내용을 복사해서 새 디렉터리 내부에 저장하자.
- 작업이 끝나면 latest 폴더의 지식 베이스 파일도 새로 업데이트된 파일로 교체하자.

중간에 생기는 오류 대응 같은 건 나중에 생각하자.

### 기존 프롬프트 내용 삭제하기

AI 스튜디오의 프롬프트 하나하나는 `ms-chat-turn` 엘리먼트로 감싸져 있다.

프롬프트를 삭제하는 버튼은 `ms-chat-turn-options` 엘리먼트로 감싸져 있다. 그리고 이 엘리먼트는 프롬프트에 마우스를 올리기 전까지 보이지 않는 상태로 존재한다.

위 엘리먼트 내부에 존재하는 유일한 button 엘리먼트를 클릭하면 프롬프트 삭제가 들어있는 팝업이 열린다.

팝업은 `mat-mdc-menu-content` 라는 클래스를 가진 엘리먼트다. 그 엘리먼트의 1번째 children이 프롬프트 삭제 버튼이다.

브라우저의 콘솔에서 아래 동작을 반복하면 모든 프롬프트를 지울 수 있는 것을 확인했다.

```js
optionsEls = document.querySelectorAll('ms-chat-turn-options');
lastOptionsEl = optionsEls[optionsEls.length - 1];

innerBtn = lastOptionsEl.querySelector('button');
innerBtn.click();

menu = document.querySelector('.mat-mdc-menu-content');
menu.children[0].click();
```

전부 지우는 스크립트는 이렇다.

```js
(async () => {
  while (true) {
    const optionsEls = document.querySelectorAll('ms-chat-turn-options');
    if (optionsEls.length === 0) {
      break;
    }

    const lastOptionsEl = optionsEls[optionsEls.length - 1];
    const innerBtn = lastOptionsEl.querySelector("button");
    if (innerBtn) {
      innerBtn.click();
    } else {
      break;
    }

    await new Promise(res => setTimeout(res, 300));

    const menu = document.querySelector('.mat-mdc-menu-content');
    if (!menu) {
      await new Promise(res => setTimeout(res, 300));
      continue;
    }

    const menuBtn = menu.children[0];
    if (menuBtn && menuBtn.tagName.toLowerCase() === "button") {
      menuBtn.click();
    } else {
      break;
    }

    await new Promise(res => setTimeout(res, 300));
  }
})();
```

### 프롬프트 입력하기

프롬프트를 입력하는 칸은 아래 엘리먼트다.

```html
<textarea _ngcontent-ng-c2013030671="" rows="1" class="textarea ng-valid ng-touched ng-dirty" placeholder="" spellcheck="true" aria-label="Type something or tab to choose an example prompt"></textarea>
```

이걸 어떻게 특정할까 생각해봤는데 의외로 `textarea` 엘리먼트가 페이지에 이거 하나밖에 없다.

```js
const textarea = document.querySelector('textarea');
textarea.value = "테스트";
textarea.dispatchEvent(new Event('input', { bubbles: true }));
```

다음은 전송 버튼을 특정하고 클릭해야 한다.

```html
<button _ngcontent-ng-c3754535447="" aria-label="Run" mattooltipclass="run-button-tooltip" class="mat-mdc-tooltip-trigger run-button ng-trigger ng-trigger-submit ng-tns-c3754535447-39 large no-timer ng-star-inserted" type="submit" aria-disabled="false" jslog="225921;track:generic_click,impression;;xFZKLc:W251bGwsIm1vZGVscy9nZW1pbmktMy1wcm8tcHJldmlldyIsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsNF0=;xFZKLc:W251bGwsIjQiLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLDVd;mutable:true" aria-describedby="cdk-describedby-message-ng-1-178" cdk-describedby-host="ng-1"><span _ngcontent-ng-c3754535447="" class="highlight ng-tns-c3754535447-39"></span><div _ngcontent-ng-c3754535447="" class="inner ng-tns-c3754535447-39"><span _ngcontent-ng-c3754535447="" class="run-button-content ng-tns-c3754535447-39 ng-star-inserted" style=""><span _ngcontent-ng-c3754535447="" class="label ng-tns-c3754535447-39 ng-star-inserted">Run</span><span _ngcontent-ng-c3754535447="" class="command ng-tns-c3754535447-39 ng-star-inserted"><span _ngcontent-ng-c3754535447="" class="secondary-key ng-tns-c3754535447-39 ng-star-inserted"> Ctrl </span><mat-icon _ngcontent-ng-c3754535447="" role="img" class="mat-icon notranslate primary-key-icon material-symbols-outlined ng-tns-c3754535447-39 material-icons mat-ligature-font mat-icon-no-color" aria-hidden="true" data-mat-icon-type="font"> keyboard_return </mat-icon></span></span></div></button>
```

상식적으로 `run-button` 이라는 클래스가 붙은 엘리먼트는 페이지에 이것 하나밖에 없을 거라고 생각했다.

확인해보니 실제로 그렇다. 

```js
const btn = document.querySelector('.run-button');
btn.click();
```

이렇게 하면 textarea에 입력을 마치고 그 결과를 전송할 수 있다.

### 답변 출력이 끝나기를 기다리기

답변이 생성되는 동안은 Run 버튼이 아래와 같이 Stop 버튼으로 변한다.

```html
<button _ngcontent-ng-c3754535447="" aria-label="Run" mattooltipclass="run-button-tooltip" class="mat-mdc-tooltip-trigger run-button ng-trigger ng-trigger-submit ng-tns-c3754535447-39 large no-timer ng-star-inserted stoppable" type="button" aria-disabled="false" jslog="250044;track:generic_click,impression;;xFZKLc:W251bGwsIm1vZGVscy9nZW1pbmktMy1wcm8tcHJldmlldyIsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsNF0=;xFZKLc:W251bGwsIjk0NCIsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsNV0=;mutable:true" aria-describedby="cdk-describedby-message-ng-1-225" cdk-describedby-host="ng-1"><span _ngcontent-ng-c3754535447="" class="highlight ng-tns-c3754535447-39"></span><div _ngcontent-ng-c3754535447="" class="inner ng-tns-c3754535447-39"><svg _ngcontent-ng-c3754535447="" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="ng-tns-c3754535447-39 ng-star-inserted" style=""><circle _ngcontent-ng-c3754535447="" fill="none" cx="50%" cy="50%" r="10" stroke-width="2" stroke-dashoffset="15.708" stroke-dasharray="62.832" class="stoppable-spinner ng-tns-c3754535447-39"></circle><rect _ngcontent-ng-c3754535447="" x="8" y="8" width="8" height="8" class="stoppable-stop ng-tns-c3754535447-39"></rect></svg><span _ngcontent-ng-c3754535447="" class="run-button-content ng-tns-c3754535447-39 ng-star-inserted" style=""><span _ngcontent-ng-c3754535447="" class="label ng-tns-c3754535447-39 ng-star-inserted" style="">Stop</span></span></div></button>
```

버튼 엘리먼트의 클래스에 `stoppable` 이 추가된 것을 확인할 수 있다.

그렇다면 출력한 답변을 복사하는 시점은 위 클래스가 사라진 뒤로 하면 된다.

### 출력된 답변 복사하기

출력된 답변을 마크다운으로 복사해서 파일로 다운로드해야 한다.

그리고 마크다운으로 복사하는 버튼은 삭제 버튼보다 3칸 아래에 있으므로 아래 스크립트로 조작할 수 있다.

```js
optionsEls = document.querySelectorAll('ms-chat-turn-options');
lastOptionsEl = optionsEls[optionsEls.length - 1];

innerBtn = lastOptionsEl.querySelector('button');
innerBtn.click();

menu = document.querySelector('.mat-mdc-menu-content');
menu.children[3].click();
```

### 스펙들을 반영한 프롬프트

```
당신은 nodejs로 아래의 스펙을 만족하는 코드를 작성해야 합니다.

- inquirer를 사용해서 experiment 폴더 내부에서 하나의 하위 폴더를 선택해야 합니다.
- 선택된 폴더 내부의 log 폴더 안에 있는 파일 중 하나를 선택해야 합니다.
- 사용자는 선택한 파일에 대한 label 값을 입력해야 합니다.
- Playwright로 https://aistudio.google.com/u/1/prompts/1XvpEt1Ygr9EKB8SA9aNuQfRH7VuGJgO- 페이지에 접속합니다. 브라우저가 작동하는 과정을 사용자가 볼 수 있어야 합니다.
- 페이지에 더 이상 ms-chat-turn-options 엘리먼트가 존재하지 않을 때까지 아래의 동작을 반복합니다.
  - ms-chat-turn-options 엘리먼트 중 맨 아래의 엘리먼트를 가져옵니다.
  - 엘리먼트 내부에 존재하는 유일한 button 엘리먼트를 클릭합니다.
  - 페이지에서 mat-mdc-menu-content 라는 클래스를 가진 엘리먼트를 가져옵니다. 그 엘리먼트의 0번째 children인 button을 클릭합니다.
- 반복을 마쳤다면 experiment 폴더 내부에서 사용자가 선택한 폴더 내부에 있는 KB.txt의 내용을 복사해서 페이지에 존재하는 유일한 textarea 엘리먼트에 입력합니다. 
- 입력을 마친 뒤 페이지에서 run-button 이라는 클래스를 가진 버튼을 클릭합니다.
- 버튼을 클릭하면 페이지에 stoppable 이라는 클래스를 가진 엘리먼트가 나타납니다. stoppable 클래스를 가진 엘리먼트가 페이지에 존재하지 않을 때까지 대기합니다.
- experiment 폴더 내부에서 사용자가 선택한 폴더 내부에 있는 update.txt의 내용을 복사해서 페이지에 존재하는 유일한 textarea 엘리먼트에 입력합니다.
  - update.txt의 내용 중 {label} 로 된 모든 부분은 사용자가 위 과정에서 입력한 label 값으로 교체되어야 합니다.
  - update.txt의 내용 중 {log} 로 된 부분은 사용자가 위 과정에서 선택한 파일의 내용으로 교체되어야 합니다. 파일 내용의 윗 줄과 아랫 줄은 ```로 감싸져 있어야 합니다.
- 입력을 마친 뒤 페이지에서 run-button 이라는 클래스를 가진 버튼을 클릭합니다.
- 버튼을 클릭하면 페이지에 stoppable 이라는 클래스를 가진 엘리먼트가 나타납니다. stoppable 클래스를 가진 엘리먼트가 페이지에 존재하지 않을 때까지 대기합니다.
- ms-chat-turn-options 엘리먼트 중 맨 아래의 엘리먼트를 가져옵니다.
- 엘리먼트 내부에 존재하는 유일한 button 엘리먼트를 클릭합니다.
- 페이지에서 mat-mdc-menu-content 라는 클래스를 가진 엘리먼트를 가져옵니다. 그 엘리먼트의 3번째 children인 button을 클릭합니다.
- 현재 클립보드에 복사된 내용 중 .md 로 끝나는 단어들을 줄 단위로 분리합니다. 
- 분리한 단어들로 아래의 작업을 반복합니다.
  - 페이지에 존재하는 유일한 textarea 엘리먼트에 단어를 입력합니다. 
  - 입력을 마친 뒤 페이지에서 run-button 이라는 클래스를 가진 버튼을 클릭합니다.
  - 버튼을 클릭하면 페이지에 stoppable 이라는 클래스를 가진 엘리먼트가 나타납니다. stoppable 클래스를 가진 엘리먼트가 페이지에 존재하지 않을 때까지 대기합니다.
  - ms-chat-turn-options 엘리먼트 중 맨 아래의 엘리먼트를 가져옵니다.
  - 엘리먼트 내부에 존재하는 유일한 button 엘리먼트를 클릭합니다.
  - 페이지에서 mat-mdc-menu-content 라는 클래스를 가진 엘리먼트를 가져옵니다. 그 엘리먼트의 3번째 children인 button을 클릭합니다.
  - 클립보드에 복사한 내용을 로컬 파일에 저장합니다. 저장할 파일의 경로는 반드시 규칙을 따라야 합니다. 복사된 단어가 code/test.md 라면 파일은 사용자가 처음에 선택한 폴더 내에서 KB/{label}/code/test.md 의 경로에 저장되어야 합니다. 사용자가 입력한 label 값이 곧 새 폴더의 이름입니다.
- 반복을 마쳤다면 새로 생성한 label 폴더의 하위 내용물들을 모두 복사해서 사용자가 처음에 선택한 폴더의 KB/latest 폴더 내에 붙여넣습니다. 동일한 파일들이 존재한다면 덮어씁니다.
- 모든 과정을 사용자가 인식하기 쉽도록 로그로 남겨야 합니다.
```


### 제미니 3 Pro의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

```js
import inquirer from 'inquirer';
import { chromium } from 'playwright';
import fs from 'fs-extra';
import path from 'path';
import clipboardy from 'clipboardy';

// 상수 정의
const EXPERIMENT_DIR = './experiment';
const GOOGLE_AI_STUDIO_URL = 'https://aistudio.google.com/u/1/prompts/1XvpEt1Ygr9EKB8SA9aNuQfRH7VuGJgO-';

async function main() {
  console.log('🚀 자동화 스크립트를 시작합니다...');

  // 1. experiment 폴더 확인
  if (!fs.existsSync(EXPERIMENT_DIR)) {
    console.error(`❌ '${EXPERIMENT_DIR}' 폴더가 존재하지 않습니다.`);
    return;
  }

  // 2. 폴더 선택 (Inquirer)
  const folders = fs.readdirSync(EXPERIMENT_DIR).filter(file => {
    return fs.statSync(path.join(EXPERIMENT_DIR, file)).isDirectory();
  });

  if (folders.length === 0) {
    console.error('❌ experiment 폴더 내부에 하위 폴더가 없습니다.');
    return;
  }

  const { selectedFolder } = await inquirer.prompt([
    {
      type: 'list',
      name: 'selectedFolder',
      message: 'experiment 폴더 내부에서 폴더를 선택하세요:',
      choices: folders,
    },
  ]);

  const targetDir = path.join(EXPERIMENT_DIR, selectedFolder);
  const logDir = path.join(targetDir, 'log');

  // 3. Log 파일 선택
  if (!fs.existsSync(logDir)) {
    console.error(`❌ '${logDir}' 폴더가 존재하지 않습니다.`);
    return;
  }

  const logFiles = fs.readdirSync(logDir).filter(file => {
    return fs.statSync(path.join(logDir, file)).isFile();
  });

  if (logFiles.length === 0) {
    console.error(`❌ '${logDir}' 내부에 파일이 없습니다.`);
    return;
  }

  const { selectedLogFile } = await inquirer.prompt([
    {
      type: 'list',
      name: 'selectedLogFile',
      message: 'log 폴더 내부에서 파일을 선택하세요:',
      choices: logFiles,
    },
  ]);

  // 4. Label 입력
  const { label } = await inquirer.prompt([
    {
      type: 'input',
      name: 'label',
      message: 'label 값을 입력하세요:',
      validate: (input) => input ? true : '값을 입력해야 합니다.',
    },
  ]);

  // 파일 내용 읽기 준비
  const kbPath = path.join(targetDir, 'KB.txt');
  const updatePath = path.join(targetDir, 'update.txt');
  const logPath = path.join(logDir, selectedLogFile);

  if (!fs.existsSync(kbPath) || !fs.existsSync(updatePath)) {
    console.error('❌ 선택한 폴더 내에 KB.txt 또는 update.txt가 없습니다.');
    return;
  }

  const kbContent = fs.readFileSync(kbPath, 'utf-8');
  let updateContent = fs.readFileSync(updatePath, 'utf-8');
  const logFileContent = fs.readFileSync(logPath, 'utf-8');

  // update.txt 내용 치환
  updateContent = updateContent.split('{label}').join(label);
  updateContent = updateContent.split('{log}').join(`\`\`\`\n${logFileContent}\n\`\`\``);

  console.log('🌐 브라우저를 실행합니다...');

  // 5. Playwright 실행
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext({
    permissions: ['clipboard-read', 'clipboard-write'], // 클립보드 권한 부여
  });
  const page = await context.newPage();

  try {
    // 페이지 접속
    await page.goto(GOOGLE_AI_STUDIO_URL);
    console.log('✅ 페이지 접속 완료. (로그인이 필요하다면 브라우저에서 직접 로그인해주세요)');

    // 페이지 로드 대기 (textarea가 나올 때까지)
    await page.waitForSelector('textarea', { timeout: 60000 });

    // 6. ms-chat-turn-options 삭제 반복 루프
    console.log('🗑️ 기존 대화 내용 삭제를 시도합니다...');
    
    // 요소가 있는지 확인하고 반복 삭제
    // 주의: 삭제 후 DOM이 변경되므로 매번 다시 조회해야 함
    while (true) {
        // ms-chat-turn-options 요소들 가져오기
        const options = page.locator('.ms-chat-turn-options');
        const count = await options.count();
        
        if (count === 0) break;

        // 맨 아래 요소 가져오기
        const lastOption = options.nth(count - 1);
        
        // 내부 버튼 클릭 (옵션 메뉴 열기)
        await lastOption.locator('button').click();

        // 메뉴가 뜰 때까지 대기
        const menuContent = page.locator('.mat-mdc-menu-content');
        await menuContent.waitFor({ state: 'visible' });

        // 0번째 버튼 클릭 (삭제 버튼 가정)
        await menuContent.locator('button').nth(0).click();

        // UI 업데이트 대기 (잠시 대기하여 처리가 완료되도록 함)
        await page.waitForTimeout(1000);
    }
    console.log('✅ 기존 대화 삭제 완료.');

    // 7. KB.txt 입력 및 실행
    console.log('📝 KB.txt 내용을 입력합니다...');
    await page.locator('textarea').fill(kbContent);
    
    const runButton = page.locator('.run-button');
    await runButton.click();
    console.log('🏃‍♂️ 실행 버튼 클릭 (KB.txt)');

    // Stoppable 대기 (생성 -> 소멸)
    await page.waitForSelector('.stoppable', { state: 'attached' });
    await page.waitForSelector('.stoppable', { state: 'detached', timeout: 0 }); // 무제한 대기
    console.log('✅ 첫 번째 실행 완료.');

    // 8. Update.txt 입력 및 실행
    console.log('📝 치환된 update.txt 내용을 입력합니다...');
    await page.locator('textarea').fill(updateContent);
    await runButton.click();
    console.log('🏃‍♂️ 실행 버튼 클릭 (update.txt)');

    // Stoppable 대기
    await page.waitForSelector('.stoppable', { state: 'attached' });
    await page.waitForSelector('.stoppable', { state: 'detached', timeout: 0 });
    console.log('✅ 두 번째 실행 완료.');

    // 9. 결과 복사 및 파일 목록 파싱
    console.log('📋 결과 파일 목록을 복사합니다...');
    
    // 마지막 챗 옵션 찾기
    const options = page.locator('.ms-chat-turn-options');
    const lastIndex = await options.count() - 1;
    const lastOption = options.nth(lastIndex);

    // 메뉴 열기
    await lastOption.locator('button').click();
    
    // 메뉴 대기 및 3번째 버튼(복사) 클릭
    const menuContent = page.locator('.mat-mdc-menu-content');
    await menuContent.waitFor({ state: 'visible' });
    await menuContent.locator('button').nth(3).click();
    
    // 클립보드 내용 읽기 (시스템 클립보드 사용)
    // 브라우저가 클립보드에 쓰는데 시간이 걸릴 수 있으므로 약간 대기
    await page.waitForTimeout(1000); 
    const clipboardContent = await clipboardy.read();

    // .md로 끝나는 단어 분리
    const lines = clipboardContent.split('\n');
    const mdFiles = [];
    lines.forEach(line => {
        // 공백으로 분리 후 .md로 끝나는 단어 찾기 (혹은 라인 자체가 경로일 수 있음)
        const words = line.split(/\s+/);
        words.forEach(word => {
            if (word.trim().endsWith('.md')) {
                mdFiles.push(word.trim());
            }
        });
    });

    // 중복 제거
    const uniqueMdFiles = [...new Set(mdFiles)];
    console.log(`🔍 발견된 md 파일 목록: ${uniqueMdFiles.join(', ')}`);

    // 10. 파일별 내용 추출 및 저장 반복
    const newLabelDir = path.join(targetDir, 'KB', label);

    for (const mdFile of uniqueMdFiles) {
        console.log(`🔄 파일 처리 중: ${mdFile}`);

        // 텍스트 입력
        await page.locator('textarea').fill(mdFile);
        await runButton.click();

        // 실행 대기
        await page.waitForSelector('.stoppable', { state: 'attached' });
        await page.waitForSelector('.stoppable', { state: 'detached', timeout: 0 });

        // 마지막 결과 복사
        const currentOptions = page.locator('.ms-chat-turn-options');
        const currentLastIdx = await currentOptions.count() - 1;
        await currentOptions.nth(currentLastIdx).locator('button').click();

        const currentMenu = page.locator('.mat-mdc-menu-content');
        await currentMenu.waitFor({ state: 'visible' });
        await currentMenu.locator('button').nth(3).click();

        // 클립보드 읽기
        await page.waitForTimeout(1000);
        const fileContent = await clipboardy.read();

        // 파일 저장 (경로: experiment/{selectedFolder}/KB/{label}/{mdFile})
        const savePath = path.join(newLabelDir, mdFile);
        
        // fs-extra의 outputFileSync는 디렉토리가 없으면 생성해줌
        fs.outputFileSync(savePath, fileContent);
        console.log(`💾 저장 완료: ${savePath}`);
    }

    // 11. 최종 복사 (KB/latest)
    console.log('📂 최신 파일들을 KB/latest 폴더로 복사합니다...');
    const latestDir = path.join(targetDir, 'KB', 'latest');

    // KB/{label} -> KB/latest
    if (fs.existsSync(newLabelDir)) {
        fs.copySync(newLabelDir, latestDir, { overwrite: true });
        console.log(`✅ 복사 완료: ${newLabelDir} -> ${latestDir}`);
    } else {
        console.warn('⚠️ 복사할 원본 폴더가 생성되지 않았습니다.');
    }

  } catch (error) {
    console.error('❌ 에러 발생:', error);
  } finally {
    // 종료 전 사용자 확인이 필요하면 아래 주석 해제
    // await page.pause(); 
    await browser.close();
    console.log('👋 작업이 종료되었습니다.');
  }
}

main();
```

</details>

### GPT-5의 결과물

<details markdown="1">
<summary>접기/펴기</summary>

```js
import inquirer from "inquirer";
import { chromium } from "playwright";
import clipboardy from "clipboardy";
import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import fsExtra from "fs-extra";

async function listSubfolders(dir) {
  const entries = await fsp.readdir(dir, { withFileTypes: true });
  return entries.filter(e => e.isDirectory()).map(d => d.name);
}

async function listFiles(dir) {
  try {
    const entries = await fsp.readdir(dir, { withFileTypes: true });
    return entries.filter(e => e.isFile()).map(f => f.name);
  } catch (e) {
    return [];
  }
}

async function ensureDir(filePath) {
  await fsExtra.ensureDir(filePath);
}

async function main() {
  const experimentsRoot = path.resolve(process.cwd(), "experiment");
  console.log("실행: experiment 폴더 위치:", experimentsRoot);

  // 1) 폴더 선택
  const subfolders = await listSubfolders(experimentsRoot);
  if (!subfolders.length) {
    console.error("experiment 폴더 내에 하위 폴더가 없습니다:", experimentsRoot);
    process.exit(1);
  }
  const { chosenFolder } = await inquirer.prompt([
    {
      type: "list",
      name: "chosenFolder",
      message: "experiment 폴더 내부에서 하위 폴더를 선택하세요:",
      choices: subfolders,
    },
  ]);
  const chosenFolderPath = path.join(experimentsRoot, chosenFolder);
  console.log("선택된 폴더:", chosenFolder, "->", chosenFolderPath);

  // 2) log 폴더 내 파일 선택
  const logDir = path.join(chosenFolderPath, "log");
  const logFiles = await listFiles(logDir);
  if (!logFiles.length) {
    console.error("선택된 폴더의 log 디렉터리에 파일이 없습니다:", logDir);
    process.exit(1);
  }
  const { chosenLogFile } = await inquirer.prompt([
    {
      type: "list",
      name: "chosenLogFile",
      message: "log 폴더 내에서 파일을 선택하세요:",
      choices: logFiles,
    },
  ]);
  const chosenLogFilePath = path.join(logDir, chosenLogFile);
  console.log("선택된 로그 파일:", chosenLogFilePath);

  // 3) label 입력
  const { label } = await inquirer.prompt([
    {
      type: "input",
      name: "label",
      message: "선택한 파일에 대한 label 값을 입력하세요:",
      validate: v => (v && v.trim() ? true : "label은 비어있을 수 없습니다."),
    },
  ]);
  const labelName = label.trim();
  console.log("입력한 label:", labelName);

  // prepare some file contents
  const kbPath = path.join(chosenFolderPath, "KB.txt");
  let kbContent = "";
  try {
    kbContent = await fsp.readFile(kbPath, "utf8");
  } catch (e) {
    console.error("KB.txt를 읽을 수 없습니다:", kbPath, e);
    process.exit(1);
  }

  let logFileContent = "";
  try {
    logFileContent = await fsp.readFile(chosenLogFilePath, "utf8");
  } catch (e) {
    console.error("선택한 로그 파일을 읽을 수 없습니다:", chosenLogFilePath, e);
    process.exit(1);
  }

  // update.txt 읽기
  const updatePath = path.join(chosenFolderPath, "update.txt");
  let updateRaw = "";
  try {
    updateRaw = await fsp.readFile(updatePath, "utf8");
  } catch (e) {
    console.error("update.txt를 읽을 수 없습니다:", updatePath, e);
    process.exit(1);
  }

  // Playwright 브라우저 실행 (헤드풀, 사용자가 보는 모드)
  console.log("브라우저 시작 (헤드풀 모드). Playwright가 작업 과정을 표시합니다...");
  const browser = await chromium.launch({ headless: false, slowMo: 50 });
  const context = await browser.newContext();
  const page = await context.newPage();

  try {
    // 페이지 접속
    const url = "https://aistudio.google.com/u/1/prompts/1XvpEt1Ygr9EKB8SA9aNuQfRH7VuGJgO-";
    console.log("페이지 열기:", url);
    await page.goto(url, { waitUntil: "domcontentloaded" });

    // 반복: ms-chat-turn-options 엘리먼트가 더 이상 존재하지 않을 때까지
    console.log("ms-chat-turn-options가 더 이상 없을 때까지 반복 시작...");
    while (true) {
      const optionsLocator = page.locator("ms-chat-turn-options");
      const count = await optionsLocator.count();
      console.log("현재 ms-chat-turn-options 개수:", count);
      if (count === 0) break;

      // 맨 아래 엘리먼트 (마지막) 선택
      const lastOption = optionsLocator.nth(count - 1);
      // 내부의 유일한 button 클릭
      const innerButton = lastOption.locator("button");
      console.log("마지막 ms-chat-turn-options 내부 버튼 클릭 시도...");
      await innerButton.click({ force: true });

      // 메뉴가 열릴 때까지 대기하고, mat-mdc-menu-content의 0번째 children인 button 클릭
      console.log("mat-mdc-menu-content의 0번째 button 클릭 대기...");
      const menuButtons = page.locator(".mat-mdc-menu-content button");
      await menuButtons.first().waitFor({ state: "visible", timeout: 10000 }).catch(() => {});
      const menuCount = await menuButtons.count();
      if (menuCount === 0) {
        console.warn("mat-mdc-menu-content 안의 버튼을 찾지 못했습니다. 계속 진행합니다.");
        continue;
      }
      console.log("mat-mdc-menu-content 버튼[0] 클릭...");
      await menuButtons.nth(0).click();
      // short delay to allow DOM update
      await page.waitForTimeout(300);
    }
    console.log("ms-chat-turn-options 반복 완료.");

    // KB.txt 입력
    console.log("KB.txt 내용을 페이지의 유일한 textarea에 입력합니다...");
    const textareas = await page.$$("textarea");
    if (textareas.length === 0) {
      throw new Error("페이지에 textarea 엘리먼트가 존재하지 않습니다.");
    }
    // 유일한 textarea가 아니어도 첫번째를 사용 (요구: 페이지에 존재하는 유일한 textarea 엘리먼트)
    const textareaSelector = "textarea";
    await page.fill(textareaSelector, kbContent);
    console.log("KB 내용 입력 완료.");

    // run-button 클릭
    console.log("run-button 클릭...");
    await page.click(".run-button");
    console.log("stoppable 엘리먼트가 나타날 때까지 대기...");
    await page.waitForSelector(".stoppable", { state: "attached", timeout: 120000 });
    console.log("stoppable 등장. 완료될 때까지 대기...");
    await page.waitForSelector(".stoppable", { state: "detached", timeout: 300000 });
    console.log("stoppable 제거(작업 완료).");

    // update.txt 처리: {label} 과 {log} 치환
    const logWrapped = "```\n" + logFileContent + "\n```";
    const updateFilled = updateRaw.split("{label}").join(labelName).split("{log}").join(logWrapped);

    console.log("update.txt의 치환된 내용을 textarea에 입력합니다...");
    await page.fill(textareaSelector, updateFilled);
    console.log("update 내용 입력 완료.");

    // run-button 클릭 및 대기
    console.log("run-button 클릭 (update)...");
    await page.click(".run-button");
    await page.waitForSelector(".stoppable", { state: "attached", timeout: 120000 });
    await page.waitForSelector(".stoppable", { state: "detached", timeout: 300000 });
    console.log("update 실행 완료 (stoppable 사라짐).");

    // ms-chat-turn-options 마지막, 내부 버튼 클릭, mat-mdc-menu-content의 3번째 children 버튼 클릭
    console.log("ms-chat-turn-options의 마지막 버튼 클릭 후 메뉴의 3번째 버튼 클릭...");
    {
      const optionsLocator = page.locator("ms-chat-turn-options");
      const count = await optionsLocator.count();
      if (count === 0) {
        throw new Error("마지막 단계에서 ms-chat-turn-options가 존재하지 않습니다.");
      }
      await optionsLocator.nth(count - 1).locator("button").click({ force: true });
      // 메뉴의 3번째 children (index 3) 클릭
      const menuButtons = page.locator(".mat-mdc-menu-content button");
      await menuButtons.first().waitFor({ state: "visible", timeout: 10000 }).catch(() => {});
      const menuCount = await menuButtons.count();
      if (menuCount <= 3) {
        console.warn("mat-mdc-menu-content에 4개 이상의 버튼이 없습니다. 가능한 최대 인덱스 클릭 시도.");
        const idx = Math.min(3, Math.max(0, menuCount - 1));
        await menuButtons.nth(idx).click();
      } else {
        await menuButtons.nth(3).click();
      }
    }
    console.log("초기 복사(또는 메뉴작업) 트리거 완료.");

    // 클립보드에 있는 .md로 끝나는 단어들을 줄 단위로 분리
    console.log("클립보드에서 .md로 끝나는 단어들을 읽어 분리합니다...");
    const clipboardRaw = await clipboardy.read();
    const lines = clipboardRaw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const mdWords = lines.filter(l => /\.md$/i.test(l));
    console.log("클립보드에서 추출된 md 항목들:", mdWords);

    // 반복: 분리한 단어들로 작업
    const labelFolderRoot = path.join(chosenFolderPath, "KB", labelName);
    for (const word of mdWords) {
      console.log("처리 시작:", word);
      // 입력 -> run -> wait -> open menu -> 클릭(3번째) -> 클립보드 읽어서 저장

      // textarea 에 단어 입력
      await page.fill(textareaSelector, word);
      console.log("단어 입력 완료:", word);

      // run-button 클릭
      await page.click(".run-button");
      await page.waitForSelector(".stoppable", { state: "attached", timeout: 120000 });
      await page.waitForSelector(".stoppable", { state: "detached", timeout: 300000 });
      console.log("실행 완료 (stoppable 사라짐) for", word);

      // ms-chat-turn-options 마지막의 버튼 클릭
      const optionsLocator = page.locator("ms-chat-turn-options");
      const count = await optionsLocator.count();
      if (count === 0) {
        console.warn("루프 중 ms-chat-turn-options가 없음 — 계속 진행합니다.");
      } else {
        await optionsLocator.nth(count - 1).locator("button").click({ force: true });
      }

      // mat-mdc-menu-content의 3번째 버튼 클릭 (가능하면)
      const menuButtons = page.locator(".mat-mdc-menu-content button");
      await menuButtons.first().waitFor({ state: "visible", timeout: 10000 }).catch(() => {});
      const menuCount = await menuButtons.count();
      if (menuCount === 0) {
        console.warn("메뉴 버튼을 찾지 못했습니다. 복사 동작이 되지 않을 수 있습니다.");
      } else {
        const idx = Math.min(3, Math.max(0, menuCount - 1));
        await menuButtons.nth(idx).click();
      }

      // 잠시 대기하여 클립보드가 채워지도록 함
      await page.waitForTimeout(500);

      // 클립보드 읽기
      const copiedContent = await clipboardy.read();
      console.log("클립보드에서 읽은 내용 길이:", copiedContent.length);

      // 저장 경로 규칙: 예: code/test.md -> KB/{label}/code/test.md
      // word이 경로일 수 있으므로 path.join 사용
      const sanitizedWord = word.replace(/^\/+/, ""); // 선행 슬래시 제거
      const destPath = path.join(labelFolderRoot, sanitizedWord);
      const destDir = path.dirname(destPath);
      await ensureDir(destDir);
      console.log("파일로 저장:", destPath);
      await fsp.writeFile(destPath, copiedContent, "utf8");
      console.log("저장 완료:", destPath);
    }

    // 반복 끝 -> 새로 생성한 label 폴더의 하위 내용물을 모두 KB/latest에 복사 (덮어쓰기)
    const latestDir = path.join(chosenFolderPath, "KB", "latest");
    console.log("label 폴더 내용을 KB/latest로 복사합니다:", labelFolderRoot, "->", latestDir);
    await ensureDir(latestDir);
    await fsExtra.copy(labelFolderRoot, latestDir, { overwrite: true });
    console.log("복사 완료. 동일한 파일 존재 시 덮어쓰기 처리됨.");

    console.log("모든 과정이 완료되었습니다.");
  } catch (err) {
    console.error("실행 중 오류 발생:", err);
  } finally {
    console.log("브라우저 종료...");
    await browser.close();
  }
}

main().catch(err => {
  console.error("Fatal error:", err);
  process.exit(1);
});
```

</details>
<br>

LLM들에게 받은 답변을 종합하고 오류 몇 가지를 수정해서 아래와 같은 코드가 완성되었다.

```js
const { chromium } = require("playwright");
const fs = require("fs-extra");
const path = require("path");

const EXPERIMENT_DIR = path.resolve("experiment");

async function selectExperimentFolder() {
  const { default: inquirer } = await import("inquirer");

  const folders = fs
    .readdirSync(EXPERIMENT_DIR)
    .filter((f) => fs.lstatSync(path.join(EXPERIMENT_DIR, f)).isDirectory());
  const { folder } = await inquirer.prompt({
    name: "folder",
    type: "list",
    message: "폴더를 선택해주세요:",
    choices: folders,
  });
  return folder;
}

async function selectLogFile(folderPath) {
  const { default: inquirer } = await import("inquirer");

  const logDir = path.join(folderPath, "log");
  const files = fs.readdirSync(logDir);
  const { file } = await inquirer.prompt({
    name: "file",
    type: "list",
    message: "로그 파일을 선택해주세요:",
    choices: files,
  });
  return path.join(logDir, file);
}

async function clickOptionMenu(page, childrenIndex) {
  await page.waitForSelector("ms-chat-turn-options");
  const prompts = await page.$$("ms-chat-turn");
  const last = prompts[prompts.length - 1];
  await last.hover();

  const options = await last.$("ms-chat-turn-options");
  const button = await options.$("button");
  await button.click();

  await page.waitForSelector(".mat-mdc-menu-content");
  const menus = await page.$$(".mat-mdc-menu-content");
  const buttons = await menus[0].$$("button");

  await buttons[childrenIndex].click();
  await page.waitForTimeout(500);
}

async function writeTextarea(page, text) {
  const { default: clipboard } = await import("clipboardy");

  await clipboard.write(text);
  const textarea = await page.$("textarea");
  await textarea.fill("");
  await textarea.click();
  await page.keyboard.press(`Control+V`);
}

async function runAndWait(page) {
  await page.click(".run-button");
  await page.waitForSelector(".stoppable");
  await page.waitForSelector(".stoppable", {
    state: "detached",
    timeout: 3000000,
  });
}

function replacePlaceholders(text, label, logContent) {
  const wrappedLog = "```\n" + logContent + "\n```";

  return text.replaceAll("{label}", label).replaceAll("{log}", wrappedLog);
}

function saveClipboardToPath(baseFolder, label, mdPath, content) {
  const fullDir = path.join(baseFolder, "KB", label, path.dirname(mdPath));
  const fullFile = path.join(fullDir, path.basename(mdPath));

  fs.mkdirSync(fullDir, { recursive: true });
  fs.writeFileSync(fullFile, content);
}

async function processMDList(page, baseFolder, label) {
  const { default: clipboard } = await import("clipboardy");

  await clickOptionMenu(page, 3);
  const clipboardContent = await clipboard.read();
  const mdLines = clipboardContent
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => line.endsWith(".md"));

  console.log("📋 업데이트된 파일 목록: ", mdLines);

  for (const mdFile of mdLines) {
    console.log(`📌 ${mdFile} 처리 중...`);

    await writeTextarea(page, mdFile);
    await runAndWait(page);
    await clickOptionMenu(page, 3);

    const copied = await clipboard.read();
    saveClipboardToPath(baseFolder, label, mdFile, copied);
  }
}

async function main() {
  const { default: inquirer } = await import("inquirer");

  // 경로 선택
  const folder = await selectExperimentFolder();
  const folderPath = path.join(EXPERIMENT_DIR, folder);
  const logPath = await selectLogFile(folderPath);
  const logContent = fs.readFileSync(logPath, "utf-8");

  const { label } = await inquirer.prompt({
    name: "label",
    type: "input",
    message: "로그 이름을 입력하세요:",
  });

  console.log(`📁 폴더: ${folder}`);
  console.log(`📝 로그: ${logPath}`);
  console.log(`🏷️ 라벨: ${label}`);

  // 구글 AI 스튜디오 접속
  const browser = await chromium.launchPersistentContext("./user_data", {
    headless: false,
    args: ["--disable-blink-features=AutomationControlled"],
    viewport: { width: 2560, height: 1080 },
  });

  const pages = browser.pages();
  const page = pages.length > 0 ? pages[0] : await browser.newPage();
  await page.goto(
    "https://aistudio.google.com/u/1/prompts/1XvpEt1Ygr9EKB8SA9aNuQfRH7VuGJgO-",
  );
  await page.waitForSelector("textarea", { timeout: 60000 });

  // 이전 대화 내역 전부 삭제
  while ((await page.$("ms-chat-turn-options")) !== null) {
    await clickOptionMenu(page, 0);
    console.log("🗑 이전 대화 내역을 삭제했습니다.");
  }

  // KB.txt 내용 입력
  const kbText = fs.readFileSync(path.join(folderPath, "KB.txt"), "utf-8");

  await writeTextarea(page, kbText);
  await runAndWait(page);

  // 사용자가 선택한 로그 내용 입력
  const updatePath = path.join(EXPERIMENT_DIR, "update.txt");
  const updateRaw = fs.readFileSync(updatePath, "utf-8");
  const replacedUpdate = replacePlaceholders(updateRaw, label, logContent);

  await writeTextarea(page, replacedUpdate);
  await runAndWait(page);

  // 업데이트된 지식 베이스 파일 목록 추출 및 반영
  await processMDList(page, folderPath, label);

  // KB/latest 폴더에 복사
  const latestDir = path.join(folderPath, "KB", "latest");
  const labelDir = path.join(folderPath, "KB", label);

  fs.cpSync(labelDir, latestDir, { recursive: true });
  console.log("📌 KB/latest 복사가 완료되었습니다!");

  await browser.close();
  console.log("\n✨ 지식 베이스 작업 완료!");
}

main().catch(console.error);
```

몇 번 테스트해보고 나서 깔끔하게 작동하는 것을 확인했다.

기능 하나하나마다 함수로 떼어 놓을까 생각했는데, 나중에 유지보수할 일이 종종 생긴다 싶으면 그때 손보자.
